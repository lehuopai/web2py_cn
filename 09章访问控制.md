## 第9章 访问控制[¶](http://web2py.com/books/default/chapter/29/09/access-control#Access-Control)





web2py 包含一个强大且可定制的基于角色的访问控制机制 (RBAC)。

这是维基百科的定义：

“Role-Based Access Control (RBAC) 是一种限制授权用户访问系统的方法。它是强制访问控制mandatory access control  (MAC) 和自主访问控制discretionary access control (DAC) 的一种较新的替代方法。RBAC 有时被称为基于角色的安全。

RBAC 是一种策略中立且灵活的访问控制技术，其功能强大到足以模拟 DAC 和 MAC。相反，如果角色图被限制为树而不是部分有序集，MAC 可以模拟 RBAC。

在 RBAC 开发之前，MAC 和 DAC 被认为是唯一已知的访问控制模型：如果一个模型不是 MAC，它被认为是一个 DAC 模型，反之亦然。1990 年代后期的研究表明，RBAC 不属于任何类别。

在组织内，为各种工作职能创建角色。执行某些操作的权限分配给特定角色。员工（或其他系统用户）被分配特定角色，并通过这些角色分配获得执行特定系统功能的权限。与基于上下文的访问控制context-based access control (CBAC) 不同，RBAC 不查看消息上下文（例如连接的源）。

由于没有直接为用户分配权限，而只是通过他们的角色（或角色）获得权限，因此管理个人用户权限变成了简单地为用户分配适当角色的问题；这简化了常见操作，例如添加用户或更改用户的部门。

RBAC 与传统自主访问控制系统中使用的访问控制列表 (ACL) 的不同之处在于，它将权限分配给在组织中有意义的特定操作，而不是分配给低级别的数据对象。例如，访问控制列表可用于授予或拒绝对特定系统文件的写访问权，但它不会规定如何更改该文件。”

实现 RBAC 的 web2py 类称为**Auth**。

**Auth**需要（并定义）下表：

- `auth_user`存储用户的姓名、电子邮件地址、密码和状态（注册待定、接受、阻止）
- `auth_group`以多对多结构存储用户的组或角色。默认情况下，每个用户都在自己的组中，但一个用户可以在多个组中，每个组可以包含多个用户。组由角色和描述标识。
- `auth_membership`以多对多的结构链接用户和组。
- `auth_permission`链接组和权限。权限由名称以及可选的表和记录来标识。例如，某个组的成员可以对特定表的特定记录具有“更新”权限。
- `auth_event`记录其他表中的更改以及通过 CRUD 成功访问由 RBAC 控制的对象。
- `auth_cas`用于中央身份验证服务 (CAS)。每个 web2py 应用程序都是 CAS 提供者，并且可以选择成为 CAS 消费者。

该架构在下图中以图形方式再现：



![图片](http://www.web2py.com/books/default/image/29/schema_auth.png)



原则上对角色名称和权限名称没有限制；开发人员可以创建它们来修复组织中的角色和权限。一旦它们被创建，web2py 会提供一个 API 来检查用户是否登录，用户是否是给定组的成员，和/或用户是否是具有给定所需权限的任何组的成员。

web2py 还提供装饰器来限制对基于登录、成员资格和权限的任何功能的访问。

web2py 还理解一些特定的权限，即那些具有与 CRUD 方法（创建、读取、更新、删除）相对应的名称的权限，并且可以自动执行它们而无需使用装饰器。

在本章中，我们将一一讨论 RBAC 的不同部分。



### 验证 Authentication

为了使用 RBAC，需要识别用户。这意味着他们需要注册（或被注册）并登录。

**Auth**提供了多种登录方式。默认包括根据本地`auth_user`表识别用户。或者，它可以针对第三方身份验证系统和单点登录提供者（如 Google、PAM、LDAP、Facebook、LinkedIn、Dropbox、OpenID、OAuth 等）登录用户。

要开始使用`Auth`，您至少需要模型文件中的此代码，该模型文件也随 web2py “欢迎”应用程序一起提供，并假定一个`db`连接对象：

```
from gluon.tools import Auth
auth = Auth(db)
auth.define_tables(username=False, signature=False)
```

默认情况下，web2py 使用电子邮件登录。相反，如果您想使用用户名集登录`auth.define_tables(username=True)`

设置`signature=True`将用户和日期标记添加到身份验证表，以跟踪修改。

Auth 有一个可选`secure=True`参数，它将强制经过身份验证的页面通过 HTTPS。



默认情况下，Auth 保护登录免受跨站点请求伪造 (CSRF)。这实际上是由 web2py 的标准 CSRF 保护在会话中生成表单时提供的。但是，在某些情况下，为登录、密码请求和重置尝试创建会话的开销可能是不可取的。DOS攻击在理论上是可能的。可以为 Auth 表单禁用 CSRF 保护（从 v 2.6 开始）：

```
Auth  =  Auth ( ... ,  csrf_prevention  =  False )
```

请注意，由于引入的安全风险，不建议纯粹为了避免繁忙站点上的会话过载而这样做。相反，请参阅部署章节以获取有关减少会话开销的建议。

> 表的`password`字段`db.auth_user`默认为`CRYPT`验证器，它需要一个`hmac_key`. 在旧版 web2py 应用程序中，您可能会看到传递给 Auth 构造函数的额外参数：`hmac_key = Auth.get_or_create_key()`. 后者是从应用程序文件夹中的文件“private/auth.key”读取 HMAC 密钥的功能。如果文件不存在，它会创建一个随机的`hmac_key`. 如果多个应用程序共享同一个 auth 数据库，请确保它们也使用相同的`hmac_key`. 这对于新应用程序不再需要，因为密码是用单独的随机盐加盐的。

如果多个应用程序共享同一个身份验证数据库，您可能需要禁用迁移：`auth.define_tables(migrate=False)`.

要公开**Auth**，您还需要控制器中的以下函数（例如在“default.py”中）：

```
def  user ():  return  dict ( form = auth ())
```

> `auth`对象和`user`动作已在脚手架应用程序中定义。

web2py 还包含一个示例视图“welcome/views/default/user.html”以正确呈现此函数，如下所示：

```
{{extend 'layout.html'}}
<h2>{{=T( request.args(0).replace('_', ' ').capitalize() )}}</h2>
<div id="web2py_user_form">
  {{=form}}
  {{if request.args(0)=='login':}}
    {{if not 'register' in auth.settings.actions_disabled:}}
      <br/><a href="{{=URL(args='register')}}">register</a>
    {{pass}}
    {{if not 'request_reset_password' in auth.settings.actions_disabled:}}
      <br/>
      <a href="{{=URL(args='request_reset_password')}}">lost password</a>
    {{pass}}
  {{pass}}
</div>
```

请注意，此函数仅显示 a `form`，因此可以使用常规自定义表单语法对其进行自定义。唯一需要注意的是，显示的表单`form=auth()`取决于`request.args(0)`; 因此，如果您将默认`auth()`登录表单替换为自定义登录表单，您可能需要`if`在视图中使用如下语句：

```
{{if request.args(0)=='login':}}...custom login form...{{pass}}
```





上面的控制器公开了多个操作：

```
http://.../[app]/default/user/register
http://.../[app]/default/user/login
http://.../[app]/default/user/logout
http://.../[app]/default/user/profile
http://.../[app]/default/user/change_password
http://.../[app]/default/user/verify_email
http://.../[app]/default/user/retrieve_username
http://.../[app]/default/user/request_reset_password
http://.../[app]/default/user/reset_password
http://.../[app]/default/user/impersonate
http://.../[app]/default/user/groups
http://.../[app]/default/user/not_authorized
```

- **register**允许用户注册。它与 CAPTCHA 集成，但默认情况下禁用。这也与“web2py.js”中定义的客户端熵计算器集成。计算器指示新密码的强度。您可以使用`IS_STRONG`验证器来防止 web2py 接受弱密码。
- **login**允许已注册的用户登录（如果注册已验证或不需要验证，如果已批准或不需要批准，如果没有被阻止）。
- **logout**会执行您所期望的操作，但也与其他方法一样，记录事件并可用于触发某些事件。
- **profile**允许用户编辑他们的个人资料，即`auth_user`表格的内容。请注意，此表没有固定结构，可以自定义。
- **change_password**允许用户以故障安全的方式更改密码。
- **验证电子邮件**。如果启用了电子邮件验证，则访问者在注册后会收到一封电子邮件，其中包含用于验证其电子邮件信息的链接。该链接指向此操作。
- **检索用户名**。默认情况下，**Auth**使用电子邮件和密码登录，但它可以选择使用用户名而不是电子邮件。在后一种情况下，如果用户忘记了他/她的用户名，该`retrieve_username`方法允许用户键入电子邮件地址并通过电子邮件检索用户名。
- **request_reset_password**。允许忘记密码的用户申请新密码。他们将收到一封指向**reset_password**的确认电子邮件。
- **impersonate**允许用户“模拟”另一个用户。这对于调试和支持目的很重要。`request.args[0]`是要模拟的用户的 id。仅当登录用户时才允许这样做`has_permission('impersonate', db.auth_user, user_id)`。您可以`auth.is_impersonating()`用来检查当前用户是否在冒充其他人。
- **groups**列出当前登录用户所属的组。
- 当访问者试图做他/她无权做的事情时，**not_authorized会显示一条错误消息**
- **navbar**是一个帮助器，它使用登录/注册/等生成一个栏。链接。

注销、配置文件、change_password、模拟和组需要登录。

默认情况下，它们都是公开的，但可以限制对其中一些操作的访问。

上述所有方法都可以通过继承**Auth**来扩展或替换。

上述所有方法都可以在单独的操作中使用。例如：

```
def mylogin(): return dict(form=auth.login())
def myregister(): return dict(form=auth.register())
def myprofile(): return dict(form=auth.profile())
...
```

要将函数的访问权限限制为仅登录的访问者，请按照以下示例装饰函数

```
@auth.requires_login () 
def  hello (): 
    return  dict ( message = 'hello %(first_name)s '  %  auth . user )
```

任何功能都可以被装饰，而不仅仅是暴露的动作。当然这仍然只是一个非常简单的访问控制示例。稍后将讨论更复杂的示例。

`auth.user_groups`.



> `auth.user`包含`db.auth_user`当前登录用户或`None`其他用户的记录副本。还有一个`auth.user_id`与`auth.user.id`（即用户中当前记录器的id）或相同的`None`。类似地，`auth.user_groups`包含一个字典，其中每个键是一个组的 id，当前登录的用户是其中的成员，值是对应的组角色。

装饰器`auth.requires_login()`以及其他`auth.requires_*`装饰器采用可选`otherwise`参数。如果注册文件或可调用对象，它可以设置为将用户重定向到的字符串。如果注册失败，则调用它。



#### 注册限制

如果您想允许访客注册但在管理员批准注册之前不允许登录：

```
auth.settings.registration_requires_approval = True
```

您可以通过 appadmin 界面批准注册。查看表格`auth_user`。待定注册的`registration_key`字段设置为“待定”。当此字段设置为空白时，注册被批准。

通过 appadmin 界面，您还可以阻止用户登录。在表中找到该用户`auth_user`并将其设置`registration_key`为“已阻止”。“被阻止”的用户不允许登录。请注意，这将阻止访问者登录，但不会强制已登录的访问者退出。如果愿意，可以使用“禁用”一词代替“阻塞”，其行为完全相同。

您还可以使用以下语句完全阻止对“注册”页面的访问：

```
auth.settings.actions_disabled.append('register')
```

如果您想让人们注册并在注册后自动登录，但仍想发送一封电子邮件进行验证，以便他们在注销后无法再次登录，除非他们完成了电子邮件中的说明，您可以通过以下方式完成：

```
auth.settings.registration_requires_verification = True
auth.settings.login_after_registration = True
```

其他的**Auth**方法也可以用同样的方式进行限制。



#### 与 OpenID、Facebook 等集成。





您可以使用 web2py 角色库访问控制并通过 OpenID、Facebook、LinkedIn、Google、Dropbox、MySpace、Flickr 等其他服务进行身份验证。最简单的方法是使用 Janrain Engage（以前称为 RPX）（Janrain.com）。

Dropbox 在第 14 章中作为一个特例进行了讨论，因为它不仅允许登录，还为登录的用户提供存储服务。

Janrain Engage 是一项提供中间件身份验证的服务。您可以在 Janrain.com 注册，注册一个域（您的应用程序的名称）和您将使用的一组 URL，它们将为您提供一个 API 密钥。

现在编辑您的 web2py 应用程序的模型，并将以下几行放在`auth`对象定义之后的某处：

```
from gluon.contrib.login_methods.rpx_account import RPXAccount
auth.settings.actions_disabled=['register', 'change_password', 'request_reset_password']
auth.settings.login_form = RPXAccount(request,
    api_key='...',
    domain='...',
    url = "http://your-external-address/%s/default/user/login" % request.application)
```

第一行导入新的登录方式，第二行禁用本地注册，第三行要求 web2py 使用 RPX 登录方式。您必须插入`api_key`由 Janrain.com 提供的您自己的域名、您在注册时选择的域以及`url`您的登录页面的外部。要获取然后登录 janrain.com，然后转到[部署][应用程序设置]。右侧有“应用程序信息”，api_key 称为“API Key (Secret)”。

该域是“应用程序域”，没有前导“https://”且没有尾随“.rpxnow.com/” 例如：如果您已将网站注册为“secure.mywebsite.org”，Janrain 会将其转换为应用程序域“https://secure-mywebsite.rpxnow.com”。



![图片](http://www.web2py.com/books/default/image/29/en6900.png)



当新用户第一次登录时，web2py 会创建一条`db.auth_user`与该用户关联的新记录。它将使用该`registration_id`字段来存储用户的唯一 ID。大多数身份验证方法还将提供用户名、电子邮件、名字和姓氏，但不能保证。提供哪些字段取决于用户选择的登录方式。如果同一用户使用不同的身份验证机制登录两次（例如一次使用 OpenID 和一次使用 Facebook），Janrain 可能无法将他/她识别为同一用户并发出不同的`registration_id`.

您可以自定义 Janrain 提供的数据与`db.auth_user`. 以下是 Facebook 的示例：

```
auth.settings.login_form.mappings.Facebook = lambda profile:            dict(registration_id = profile["identifier"],
                 username = profile["preferredUsername"],
                 email = profile["email"],
                 first_name = profile["name"]["givenName"],
                 last_name = profile["name"]["familyName"])
```

字典中的键是字段，`db.auth_user`值是 Janrain 提供的配置文件对象中的数据条目。有关后者的详细信息，请查看在线 Janrain 文档。

Janrain 还将保留有关您的用户登录的统计信息。

此登录表单与 web2py 基于角色的访问控制完全集成，您仍然可以创建组、使用户成为组的成员、分配权限、阻止用户等。

> Janrain 的免费基本服务每年最多允许 2500 名唯一注册用户登录。容纳更多用户需要升级到他们的付费服务等级之一。
>
> 如果您不想使用 Janrain 并希望使用不同的登录方法（LDAP、PAM、Google、OpenID、OAuth/Facebook、LinkedIn 等），您可以这样做。本章稍后将介绍执行此操作的 API。



#### 验证码和重新验证码



为防止垃圾邮件发送者和机器人在您的网站上注册，您可能需要注册验证码。web2py 支持 开箱即用的reCAPTCHA [ [recaptcha](http://web2py.com/books/default/reference/29/recaptcha) ] 。这是因为 reCAPTCHA 设计得非常好，免费，可访问（它可以向访问者读取单词），易于设置，并且不需要安装任何第三方库。



这是使用 reCAPTCHA 需要做的：

- 注册 reCAPTCHA [ [recaptcha](http://web2py.com/books/default/reference/29/recaptcha) ] V2 并为您的帐户获取 (PUBLIC_KEY, PRIVATE_KEY) 对。这只是两个字符串。
- `auth`定义对象后，将以下代码附加到您的模型中：

```
from gluon.tools import Recaptcha2
auth.settings.captcha = Recaptcha2(request,
    'PUBLIC_KEY', 'PRIVATE_KEY')
```

如果您以“localhost”或“127.0.0.1”的身份访问网站，reCAPTCHA 可能无法正常工作，因为它已注册为仅适用于公开可见的网站，除非您将它们添加到 reCAPTCHA 管理面板中的域。

构造`Recaptcha2`函数接受一些可选参数：

```
Recaptcha2 ( ... ,  error_message = 'invalid' ,  label = 'Verify:' ,  options = {})
```

有一个实验性参数 ，`ajax=True`它使用 ajax API 来重新验证。它可以与任何 recaptcha 一起使用，但它是专门添加的，以允许 recpatcha 字段在 LOAD 表单中工作（有关 LOAD 的更多信息，请参阅第 12 章，它允许 web2py 使用 ajax '插件'页面的组件）。它是实验性的，因为它可能会被自动检测何时需要 ajax 所取代。

```
options`可能是配置字典，例如`options={theme: 'white', size: 'normal'}
```

更多细节：[reCAPTCHA ](http://www.google.com/recaptcha)[ [recaptchagoogle](http://web2py.com/books/default/reference/29/recaptchagoogle) ]和[配置](https://developers.google.com/recaptcha/docs/display#config)。

如果您不想使用 reCAPTCHA，请查看`Recaptcha2`“gluon/tools.py”中类的定义，因为它很容易使用其他 CAPTCHA 系统。

请注意，这`Recaptcha2`只是一个扩展的助手`DIV`。它生成一个验证使用`reCaptcha`服务的虚拟字段，因此，它可以以任何形式使用，包括使用定义的 FORM：

```
form  =  FORM ( INPUT ( ... ),  Recaptcha2 ( ... ),  INPUT ( _type = 'submit' ))
```

您可以通过注入在所有类型的 SQLFORM 中使用它：

```
form = SQLFORM(...) or SQLFORM.factory(...)
form.insert(-1, TR('', Recaptcha2(...), ''))
```



#### 定制`Auth`

呼吁

```
auth.define_tables()
```

定义所有尚未定义的**Auth表。**这意味着如果您希望这样做，您可以定义自己的`auth_user`表。

有多种方法可以自定义身份验证。最简单的方法是添加额外的字段：

```
## after auth = Auth(db)
auth.settings.extra_fields['auth_user']= [
  Field('address'),
  Field('city'),
  Field('zip'),
  Field('phone')]
## before auth.define_tables(username=True)
```

您不仅可以为表“auth_user”声明额外字段，还可以为其他“auth_”表声明额外字段。使用`extra_fields`是推荐的方式，因为它不会破坏任何内部机制。

另一种方法是自己定义身份验证表，虽然不是很推荐，但可以做到这一点。如果在使用表之前声明了表`auth.define_tables()`而不是默认表。这是如何做到的：

```
## after auth = Auth(db)
db.define_table(
    auth.settings.table_user_name,
    Field('first_name', length=128, default=''),
    Field('last_name', length=128, default=''),
    Field('email', length=128, default='', unique=True), # required
    Field('password', 'password', length=512,            # required
          readable=False, label='Password'),
    Field('address'),
    Field('city'),
    Field('zip'),
    Field('phone'),
    Field('registration_key', length=512,                # required
          writable=False, readable=False, default=''),
    Field('reset_password_key', length=512,              # required
          writable=False, readable=False, default=''),
    Field('registration_id', length=512,                 # required
          writable=False, readable=False, default=''))

## do not forget validators
custom_auth_table = db[auth.settings.table_user_name] # get the custom_auth_table
custom_auth_table.first_name.requires =   IS_NOT_EMPTY(error_message=auth.messages.is_empty)
custom_auth_table.last_name.requires =   IS_NOT_EMPTY(error_message=auth.messages.is_empty)
custom_auth_table.password.requires = [IS_STRONG(), CRYPT()]
custom_auth_table.email.requires = [
  IS_EMAIL(error_message=auth.messages.invalid_email),
  IS_NOT_IN_DB(db, custom_auth_table.email)]

auth.settings.table_user = custom_auth_table # tell auth to use custom_auth_table

## before auth.define_tables()
```

您可以添加任何您希望的字段，并且您可以更改验证器，但您不能删除此示例中标记为“必填”的字段。

制作“password”、“registration_key”、“reset_password_key”和“registration_id”字段很重要`readable=False`，`writable=False`因为不允许访问者篡改它们。

如果您添加一个名为“用户名”的字段，它将代替“电子邮件”用于登录。如果这样做，您还需要添加一个验证器：

```
auth_table 。用户名。需要 =  IS_NOT_IN_DB ( db ,  auth_table.username ) _ _
```

请注意，Auth 将登录用户缓存在会话中，这就是您进入的内容`auth.user`，因此您需要清除会话以在其中反映额外的字段更改。



#### 重命名`Auth`表

[重命名_auth_tables]

表的实际名称`Auth`存储在

```
auth.settings.table_user_name = 'auth_user'
auth.settings.table_group_name = 'auth_group'
auth.settings.table_membership_name = 'auth_membership'
auth.settings.table_permission_name = 'auth_permission'
auth.settings.table_event_name = 'auth_event'
```

`auth`在定义对象之后和定义 Auth 表之前，可以通过重新分配上述变量来更改表的名称。例如：

```
auth = Auth(db)
auth.settings.table_user_name = 'person'
#...
auth.define_tables()
```

也可以独立于它们的实际名称来引用实际的表，通过

```
auth.settings.table_user
auth.settings.table_group
auth.settings.table_membership
auth.settings.table_permission
auth.settings.table_event
```

注意： auth.signature 是在初始化 Auth 时定义的，这是在您设置自定义表名称之前。为避免这种情况，请执行以下操作：

```
auth = Auth(db, signature=False)
```

在这种情况下，auth.signature 将改为在您调用 auth.define_tables() 时定义，此时自定义表名称将已设置。



#### 其他登录方式和登录表格





Auth 提供了多种登录方法和挂钩来创建新的登录方法。每种支持的登录方式对应文件夹中的一个文件

```
gluon / contrib / login_methods /
```

有关每种登录方法，请参阅文件本身中的文档，但这里有一些示例。

首先，我们需要区分两种备用登录方式：

- 使用 web2py 登录表单的登录方法（尽管凭据在 web2py 外部验证）。一个例子是 LDAP。
- 需要外部单点登录表单的登录方法（例如 Google 和 Facebook）。

在后一种情况下，web2py 永远不会获取登录凭据，只会获取服务提供商颁发的登录令牌。令牌存储在`db.auth_user.registration_id`.

让我们考虑第一种情况的示例：

##### 基本的

假设您有一个身份验证服务，例如在 url

```
https://basic.example.com
```

接受基本访问身份验证。这意味着服务器接受带有以下格式标头的 HTTP 请求：

```
GET /index.html HTTP/1.0
Host: basic.example.com
Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
```

其中后一个字符串是字符串 username:password 的 base64 编码。如果用户被授权，则服务响应 200 OK，否则响应 400、401、402、403 或 404。

您想使用标准`Auth`登录表单输入用户名和密码，并针对此类服务验证凭据。您需要做的就是将以下代码添加到您的应用程序中

```
from gluon.contrib.login_methods.basic_auth import basic_auth
auth.settings.login_methods.append(
    basic_auth('https://basic.example.com'))
```

请注意，这`auth.settings.login_methods`是按顺序执行的身份验证方法列表。默认情况下，它设置为

```
auth.settings.login_methods = [auth]
```

当附加替代方法时，例如`basic_auth`Auth**首先**尝试根据 的内容登录访问者`auth_user`，当失败时，它会尝试列表中的下一个方法。如果某个方法成功登录访问者，并且 if `auth.settings.login_methods[0]==auth`，`Auth`则执行以下操作：

- 如果用户在 中不存在`auth_user`，则创建一个新用户并存储用户名/电子邮件和密码。
- 如果用户确实存在`auth_user`但新接受的密码与旧存储的密码不匹配，则旧密码将替换为新密码（请注意，除非另有说明，否则密码始终存储散列）。

如果您不希望将新密码存储在 中`auth_user`，则只需更改登录方法的顺序，或`auth`从列表中删除即可。例如：

```
from gluon.contrib.login_methods.basic_auth import basic_auth
auth.settings.login_methods =     [basic_auth('https://basic.example.com')]
```

这同样适用于此处描述的任何其他登录方法。

##### SMTP 和 Gmail





您可以使用远程 SMTP 服务器验证登录凭据，例如 Gmail；即，如果用户提供的电子邮件和密码是访问 Gmail SMTP 服务器的有效凭据，则您登录用户 ( `smtp.gmail.com:587`)。所需要的只是以下代码：

```
from gluon.contrib.login_methods.email_auth import email_auth
auth.settings.login_methods.append(
    email_auth("smtp.gmail.com:587", "@gmail.com"))
```

的第一个参数`email_auth`是 SMTP 服务器的地址：端口。第二个参数是电子邮件域。

这适用于任何需要 TLS 身份验证的 SMTP 服务器。



##### PAM

使用 Pluggable Authentication Modules (PAM) 的身份验证与之前的情况一样。它允许 web2py 使用操作系统帐户对用户进行身份验证：

```
from gluon.contrib.login_methods.pam_auth import pam_auth
auth.settings.login_methods.append(pam_auth())
```

##### LDAP

使用 LDAP 的身份验证与前面的情况非常相似。

在 MS Active Directory 中使用 LDAP 登录：



```
from gluon.contrib.login_methods.ldap_auth import ldap_auth
auth.settings.login_methods.append(ldap_auth(mode='ad',
   server='my.domain.controller',
   base_dn='ou=Users,dc=domain,dc=com'))
```

在 Lotus Notes 和 Domino 中使用 LDAP 登录：

```
auth.settings.login_methods.append(ldap_auth(mode='domino',
   server='my.domino.server'))
```

```

```

要将 LDAP 登录与 OpenLDAP（使用 UID）一起使用：



```
auth.settings.login_methods.append(ldap_auth(server='my.ldap.server',
   base_dn='ou=Users,dc=domain,dc=com'))
```

要将 LDAP 登录与 OpenLDAP（使用 CN）一起使用：

```
auth.settings.login_methods.append(ldap_auth(mode='cn',
   server='my.ldap.server', base_dn='ou=Users,dc=domain,dc=com'))）
```

还有额外的参数让 web2py

- 从 LDAP 中读取用户名等附加数据
- 实施群控
- 限制登录访问。

`ldap_auth`请参阅in的文档`web2py/gluon/contrib/login_methods/ldap_auth.py`。

##### 谷歌应用引擎

在 Google App Engine 上运行时使用 Google 进行身份验证需要跳过 web2py 登录表单，重定向到 Google 登录页面，并在成功后返回。因为行为与前面的示例不同，所以 API 略有不同。

```
from gluon.contrib.login_methods.gae_google_login import GaeGoogleAccount
auth.settings.login_form = GaeGoogleAccount()
```

##### 开放ID

我们之前讨论过与 Janrain 的集成（支持 OpenID），这是使用 OpenID 的最简单方法。然而，有时您不想依赖第三方服务，而是想直接从消费者（您的应用程序）访问 OpenID 提供程序。

这是一个例子：

```
from gluon.contrib.login_methods.openid_auth import OpenIDAuth
auth.settings.login_form = OpenIDAuth(auth)
```

`OpenIDAuth`需要单独安装*python-openid模块。*在后台，此登录方法定义了下表：

```
db.define_table('alt_logins',
    Field('username', length=512, default=''),
    Field('type', length =128, default='openid', readable=False),
    Field('user', self.table_user, readable=False))
      
```

它存储每个用户的 openid 用户名。如果要显示当前登录用户的 openids：

```
{{=auth.settings.login_form.list_user_openids()}}

```

##### OAuth2.0





我们之前讨论过与 Janrain 的集成，但有时您不想依赖第三方服务而想直接访问 OAuth2.0 提供程序；例如，Facebook、Linkedin、Twitter、Google 都提供了 OAuth2.0 认证服务。web2py 透明地处理 OAuth2.0 流程，以便在登录期间可以根据任何配置的 OAuth2.0 提供程序验证用户。除了身份验证之外，OAuth2.0 提供者还可以授予任何 web2py 应用程序访问用户资源的权限，这些用户资源的访问权限受限于专有 API。Google、Twitter、Facebook 等等，都有可以通过 web2py 应用程序轻松访问的 API。

必须强调的是，OAuth2.0 仅限于身份验证和授权（例如 CAS 具有更多功能），这意味着每个 OAuth2.0 提供者都有不同的方式通过其 API 之一从其用户数据库接收唯一 ID . 具体方法在各自的提供者文档中有很好的解释，它们通常包含在一个非常简单的 REST 调用中。这就是为什么每个 OAuth2.0 提供者都需要编写几行代码的原因。

在应用程序模型中编写任何指令之前，任何提供者都需要第一步：注册新应用程序；这通常在提供商的网站上完成，并在提供商的文档中进行了说明。

一旦需要向您的应用程序添加新的 OAuth2.0 提供程序，需要了解一些事项： 1. 授权 URI；2. Token请求URI；3. 新应用注册时收到的应用识别令牌和秘密；4.提供者必须授予web2py应用程序的权限，即“范围”（见提供者的文档）；5. 用于接收身份验证用户的 UID 的 API 调用，如提供者文档中所述。

第 1 到 4 点用于初始化 web2py 用来与 OAuth2.0 提供者通信的授权端点。唯一 id 由 web2py 在登录流程中需要时调用 get_user() 方法检索；这是需要第 5 点的 API 调用的地方。

这些是需要在您的模型中进行的基本修改：导入 OAuthAccount 类；湾。定义派生的 OAuthClass 实现；C。覆盖该类的 __init__() 方法；d。覆盖该类的 get_user() 方法。e. 使用上述列表中第 1-4 点的数据实例化该类；

一旦类被实例化，并且用户被认证，web2py 应用程序可以通过调用该类的 accessToken() 方法使用 OAuth2.0 访问令牌随时访问提供者的 API。

以下是可以与 Facebook 一起使用的示例。这是一个使用 Facebook Graph API 的基本示例，提醒一下，通过编写适当的 get_user() 方法，可以完成许多不同的事情。该示例显示了在调用提供者的远程 API 时如何使用 OAuth2.0 访问令牌。

首先，您必须安装[Facebook Python SDK](https://github.com/pythonforfacebook/facebook-sdk/)。

其次，您的模型中需要以下代码：

```
## Define oauth application id and secret.
FB_CLIENT_ID='xxx'
FB_CLIENT_SECRET="yyyy"

## import required modules
try:
    import json
except ImportError:
    from gluon.contrib import simplejson as json
from facebook import GraphAPI, GraphAPIError
from gluon.contrib.login_methods.oauth20_account import OAuthAccount


## extend the OAUthAccount class
class FaceBookAccount(OAuthAccount):
    """OAuth impl for FaceBook"""
    AUTH_URL="https://graph.facebook.com/oauth/authorize"
    TOKEN_URL="https://graph.facebook.com/oauth/access_token"

    def __init__(self):
        OAuthAccount.__init__(self, None, FB_CLIENT_ID, FB_CLIENT_SECRET,
                              self.AUTH_URL, self.TOKEN_URL,
                              scope='email,user_about_me,user_activities, user_birthday, user_education_history, user_groups, user_hometown, user_interests, user_likes, user_location, user_relationships, user_relationship_details, user_religion_politics, user_subscriptions, user_work_history, user_photos, user_status, user_videos, publish_actions, friends_hometown, friends_location,friends_photos',
                              state="auth_provider=facebook",
                              display='popup')
        self.graph = None

    def get_user(self):
        '''Returns the user using the Graph API.
        '''
        if not self.accessToken():
            return None

        if not self.graph:
            self.graph = GraphAPI((self.accessToken()))

        user = None
        try:
            user = self.graph.get_object("me")
        except GraphAPIError, e:
            session.token = None
            self.graph = None

        if user:
            if not user.has_key('username'):
                username = user['id']
            else:
                username = user['username']
                
            if not user.has_key('email'):
                email = '%s.fakemail' %(user['id'])
            else:
                email = user['email']    

            return dict(first_name = user['first_name'],
                        last_name = user['last_name'],
                        username = username,
                        email = '%s' %(email) )

## use the above class to build a new login form
auth.settings.login_form=FaceBookAccount()
```

##### 领英

我们之前讨论过与 Janrain 的集成（有 LinkedIn 支持），这是使用 OAuth 的最简单方法。然而，有时您不想依赖第三方服务，或者您可能想直接访问 LinkedIn 以获取比 Janrain 提供的更多信息。

这是一个例子：

```
from gluon.contrib.login_methods.linkedin_account import LinkedInAccount
auth.settings.login_form=LinkedInAccount(request,KEY,SECRET,RETURN_URL)
```

`LinkedInAccount`需要单独安装“python-linkedin”模块。

##### X509

您还可以通过向页面传递 x509 证书来登录，您的凭据将从证书中提取。这需要`M2Crypto`从安装

```
http://chandlerproject.org/bin/view/Projects/MeTooCrypto
```

安装 M2Cryption 后，您可以执行以下操作：

```
from gluon.contrib.login_methods.x509_auth import X509Account
auth.settings.actions_disabled=['register', 'change_password', 'request_reset_password']
auth.settings.login_form = X509Account()
```

您现在可以通过 x509 证书向 web2py 进行身份验证。如何做到这一点取决于浏览器，但您可能更有可能将证书用于 Web 服务。在这种情况下，您可以使用例如`cURL`尝试您的身份验证：

```
curl -d "firstName=John&lastName=Smith" -G -v --key private.key      --cert  server.crt https://example/app/default/user/profile
```

这与 Rocket（web2py 内置 Web 服务器）开箱即用，但如果您使用不同的 Web 服务器，您可能需要在 Web 服务器端进行一些额外的配置工作。特别是，您需要告诉您的 Web 服务器证书在本地主机上的位置，并且它需要验证来自客户端的证书。如何做到这一点取决于 Web 服务器，因此在此省略。

##### 多个登录表单

有些登录方法会修改 login_form，有些则不会。当他们这样做时，他们可能无法共存。然而，有些则通过在同一页面中提供多个登录表单来共存。web2py 提供了一种方法来做到这一点。这是一个混合普通登录 (auth) 和 RPX 登录 (janrain.com) 的示例：

```
from gluon.contrib.login_methods.extended_login_form import ExtendedLoginForm
other_form = RPXAccount(request, api_key='...', domain='...', url='...')
auth.settings.login_form = ExtendedLoginForm(auth, other_form, signals=['token'])
```

如果设置了信号并且请求中的参数匹配任何信号，它将返回调用`other_form.login_form`。`other_form`可以处理一些特殊的情况，比如OpenID里面的多步登录`other_form.login_form`。

否则它将与`other_form`.



#### 记录版本控制

您可以使用 Auth 启用完整记录版本控制：

```
auth.enable_record_versioning(db,
    archive_db=None,
    archive_names='%(tablename)s_archive',
    current_record='current_record'):
```

这告诉 web2py 为其中的每个表创建一个存档表，`db`并在修改时存储每个记录的副本。旧副本被存储。新副本不是。

最后三个参数是可选的：

- `archive_db`允许指定要存储存档表的另一个数据库。将其设置`None`为 与将其设置为 相同`db`。
- `archive_names`提供了命名每个归档表的模式。
- `current_record`指定要在存档表中使用的引用字段的名称，以引用原始的、未修改的记录。请注意，`archive_db!=db`引用字段只是一个整数字段，因为跨数据库引用是不可能的。

只有带有`modified_by`和`modified_on`字段的表（例如由 auth.signature 创建）将被存档。

当你`enable_record_versioning`，如果记录有一个`is_active`字段（也由 auth.signature 创建），记录将永远不会被删除，但它们将被标记为`is_active=False`。事实上，为每个版本化表`enable_record_versioning`添加一个过滤掉记录的版本，因此它们基本上变得不可见。`common_filter``is_active=False`

如果你`enable_record_versioning`，你不应该使用`auth.archive`，`crud.archive`否则你会得到重复的记录。这些函数明确地做了`enable_record_versioning`自动做的事情，它们将被弃用。





#### `Mail`和`Auth`

[您可以在第 8 章](http://web2py.com/books/default/chapter/29/08)阅读更多关于电子邮件和电子邮件配置的 web2py API 的信息。在这里，我们将讨论限制在 和 之间的`Mail`交互`Auth`。

定义一个邮件程序

```
from gluon.tools import Mail
mail = Mail()
mail.settings.server = 'smtp.example.com:25'
mail.settings.sender = 'you@example.com'
mail.settings.login = 'username:password'
```

或者干脆使用提供的邮件`auth`：

```
mail = auth.settings.mailer
mail.settings.server = 'smtp.example.com:25'
mail.settings.sender = 'you@example.com'
mail.settings.login = 'username:password'
```

您需要将 mail.settings 替换为您的 SMTP 服务器的正确参数。`mail.settings.login = None`如果 SMTP 服务器不需要身份验证，则设置。如果您不想使用 TLS，请设置`mail.settings.tls = False`

在`Auth`中，默认情况下禁用电子邮件验证。要启用电子邮件，请在定义的模型中附加以下行`auth`：

```
auth.settings.registration_requires_verification = True
auth.settings.registration_requires_approval = False
auth.settings.reset_password_requires_verification = True
auth.messages.verify_email = 'Click on the link %(link)s to verify your email'
auth.messages.reset_password = 'Click on the link %(link)s to reset your password'
```

在上述两个`auth.messages`中，您可能需要将字符串的 URL 部分替换为操作的正确完整 URL。这是必要的，因为 web2py 可能安装在代理之后，它无法绝对确定自己的公共 URL。但是，上述示例（它们是默认值）应该在大多数情况下都有效。





#### 两步验证

两步验证（或双因素身份验证）是一种提高身份验证安全性的方法。该设置在登录过程中增加了一个额外的步骤。第一步，向用户显示标准的用户名/密码表单。如果他们通过提交正确的用户名和密码成功通过了这个挑战，并且为用户启用了双因素身份验证，则服务器将在他们登录之前显示第二个表单。



![图片](http://www.web2py.com/books/default/image/29/two_factor_steps.png)



##### 可以基于每个用户启用此功能：

对于用户可以自行启用/禁用双因素身份验证的应用程序来说，这种情况是一个很好的例子。

此表单将要求用户提供已通过电子邮件发送到其帐户的六位数代码（如果用户名和密码正确，服务器会通过电子邮件发送代码）。默认情况下，用户将尝试 3 次引入代码。如果 3 次尝试后代码不正确，则将第二个验证步骤视为失败，用户必须再次完成第一个质询（用户名/密码）。

- 为两步验证创建一个组（也称为角色）。在这个例子中，它将被调用`auth2step`并且描述可能是`Two-step verification`。
- 授予此角色的用户成员资格。
- 在您创建和配置身份验证对象的模型中添加以下设置（可能在模型 db.py 中）：

```
auth.settings.two_factor_authentication_group = "auth2step"
```

- 不要忘记在 db.py 中配置电子邮件服务器

##### 可以为整个应用启用此功能：

此表单将要求用户提供已通过电子邮件发送到其帐户的六位数代码（如果用户名和密码正确，服务器会通过电子邮件发送代码）。默认情况下，用户将尝试 3 次引入代码。如果 3 次尝试后代码不正确，则将第二个验证步骤视为失败，用户必须再次完成第一个质询（用户名/密码）。

```
auth.settings.auth_two_factor_enabled = True
```

这种情况将影响应用程序中的所有用户。例如，如果您的办公室 IP 是 93.56.854.54，并且您不希望从办公室 IP 进行双重身份验证。在您的模型中：

```
if request.env.remote_addr != '93.56.854.54':
    auth.settings.auth_two_factor_enabled = True
```

##### 可以应用于之前示例的其他选项：

###### 示例 1：如果您想通过 SMS 而不是电子邮件发送代码。在你的模型中写：

```
def _sendsms(user, auth_two_factor):
    #write the process to send the auth_two_factor code by SMS
    return  auth_two_factor

auth.settings.auth_two_factor_enabled = True
auth.messages.two_factor_comment = "Your code have been sent by SMS"
auth.settings.two_factor_methods = [lambda user, auth_two_factor: _sendsms(user, auth_two_factor)]
```

`def _sendsms(...)`接收两个值：user 和 auth_two_factor ：

- 用户：这是一个包含他所有参数的行。您可以访问它们：user.email、user.first_name 等。
- auth_two_factor：包含验证码的字符串。

请注意，如果您想发送短信，则需要添加额外的字段，例如`phone`在您的用户表中。在这种情况下，您可以使用 访问电话字段`user.phone`。更多信息如何使用 web2py[电子邮件和短信发送短信](http://web2py.com/books/default/chapter/29/08/emails-and-sms#Emails-and-SMS)

###### 示例 2：如果您想通过短信发送代码并创建或拥有代码：

```
def _sendsms(user, auth_two_factor):
    auth_two_factor = #write your own  algorithm to generate the code.
    #write the process to send the auth_two_factor code by SMS
    return  auth_two_factor

auth.settings.two_factor_methods = [lambda user, auth_two_factor: _sendsms(user, auth_two_factor)]
```

###### 示例 3：代码由外部客户端生成。例如移动 OTP 客户端：

MOTP（移动一次性密码）允许您使用在 motp 客户端上生成的一次性密码 (OTP) 登录，motp 客户端几乎可用于所有平台。要了解有关 OTP 的更多信息，请访问[wiki-One-time-password](http://en.wikipedia.org/wiki/One-time_password)了解更多信息，请访问[MOTP](http://motp.sourceforge.net/)

对于下一个示例，我们将使用 DroidOTP。这是一个免费的应用程序，可以在 Android 的 Play 商店中找到。安装后：

- 例如，创建一个新的配置文件`test`
- 初始化一个震动你手机的密钥。

在您的模型中复制并粘贴：

```
#Before define tables, we add some extra field to auth_user
auth.settings.extra_fields['auth_user'] = [
    Field('motp_secret', 'password', length=512, default='', label='MOTP Secret'),
    Field('motp_pin', 'string', length=128, default='', label='MOTP PIN')]

OFFSET = 60 #Be sure is the same in your OTP Client

#Set session.auth_two_factor to None. Because the code is generated by external app. 
# This will avoid to use the default setting and send a code by email.
def _set_two_factor(user, auth_two_factor):
    return None

def verify_otp(user, otp):
  import time
  from hashlib import md5
  epoch_time = int(time.time())
  time_start = int(str(epoch_time - OFFSET)[:-1])
  time_end = int(str(epoch_time + OFFSET)[:-1])
  for t in range(time_start - 1, time_end + 1):
     to_hash = str(t) + user.motp_secret + user.motp_pin
     hash = md5(to_hash).hexdigest()[:6]
     if otp == hash:
       return hash

auth.settings.auth_two_factor_enabled = True
auth.messages.two_factor_comment = "Verify your OTP Client for the code."
auth.settings.two_factor_methods = [lambda user, auth_two_factor: _set_two_factor(user, auth_two_factor)]
auth.settings.two_factor_onvalidation = [lambda user, otp: verify_otp(user, otp)]
```

之前用手机生成的秘钥需要引入`motp_secret`现场。出于安全原因，不应重复使用该密钥。选择一个 PIN。它可以是数字、字母或混合。转到您的手机，选择您的个人资料并输入您之前在表格中介绍的 PIN。您获得了要在您的应用程序中使用的身份验证器代码！



![图片](http://www.web2py.com/books/default/image/29/motp.png)



请注意，对于这种双重身份验证方式，电话和服务器（托管 web2py 应用程序的位置）需要同步（准时）。他们可以在不同的时区。这是因为 OTP 使用 Unix 时间戳。它以运行总秒数跟踪时间。

##### 一些额外的配置参数：

设置您的自定义登录尝试：

```
auth.setting.auth_two_factor_tries_left = 3
```

在代码不正确时返回的消息：

```
auth.messages.invalid_two_factor_code = 'Incorrect code. {0} more attempt(s) remaining.'
```

要自定义电子邮件模板：

```
auth.messages.retrieve_two_factor_code='Your temporary login code is {0}'
auth.messages.retrieve_two_factor_code_subject='Your temporary login code is {0}'
```

自定义二元形式：

```
auth.messages.label_two_factor = 'Authentication code'
auth.messages.two_factor_comment = 'The code was emailed to you and is required for login.'
```



### 授权 Authorization

注册新用户后，将创建一个新组以包含该用户。新用户的角色通常是“user_[id]”，其中 [id] 是新创建用户的 id。可以通过以下方式禁用组的创建

```
auth.settings.create_user_groups = None
```

尽管我们不建议这样做。请注意，`create_user_groups`它不是布尔值（尽管它可以是`False`），但它默认为：

```
auth.settings.create_user_groups="user_%(id)s"
```

它存储为 user 创建的组的名称模板`id`。

用户在组中具有成员资格。每个组由名称/角色标识。组有权限。用户拥有权限是因为他们所属的组。默认情况下，每个用户都是他们自己组的成员。

你也可以做

```
auth.settings.everybody_group_id = 5
```

使任何新用户自动成为组号 5 的成员。这里以 5 为例，我们假设该组已经创建。

**您可以通过appadmin**或以编程方式使用以下方法创建组、授予成员资格和权限：

```
auth.add_group('role', 'description')
```

返回新创建的组的 id。

```
auth.del_group(group_id)
```

删除带有 的组`group_id`。

```
auth.del_group(auth.id_group('user_7'))
```

删除角色为“user_7”的组，即与用户号 7 唯一关联的组。

```
auth.user_group(user_id)
```

返回与由 标识的用户唯一关联的组的 ID `user_id`。

```
auth.add_membership(group_id, user_id)
```

给出`user_id`组的成员资格`group_id`。如果`user_id`未指定，则 web2py 假定当前登录用户。

```
auth.del_membership(group_id, user_id)
```

撤销`user_id`组的成员资格`group_id`。如果`user_id`未指定，则 web2py 假定当前登录用户。

```
auth.has_membership(group_id, user_id, role)
```

检查是否`user_id`具有组`group_id`或具有指定角色的组的成员资格。只有`group_id`or`role`应该被传递给函数，而不是两者。如果`user_id`未指定，则 web2py 假定当前登录用户。

注意：为了避免在使用 auth.has_membership 的每个页面加载时进行数据库查询，有人可以使用 cached=True。如果 cached 设置为 True has_membership() 检查 group_id 或 role 仅针对 auth.user_groups 变量，该变量仅在登录时正确填充。这意味着如果在给定会话期间用户成员资格发生变化，则用户必须注销并再次登录才能正确重新创建 auth.user_groups 并反映用户成员资格修改。此注销和登录过程有一个例外，即用户更改自己的成员资格，在这种情况下，可以为实际连接的用户正确更新 auth.user_groups，因为 web2py 可以访问正确的会话 user_groups 变量。要利用此异常，必须放置一个“auth.update_groups()” 他的应用程序代码中的指令强制更新 auth.user_groups。如前所述，这仅在用户本身更改其成员资格时才有效，而不是如果另一个用户（比如说管理员）更改其他人的成员资格。

```
auth.add_permission(group_id, 'name', 'object', record_id)
```

将对象“object”（也是用户定义）的权限“name”（用户定义）授予 group 的成员`group_id`。如果“object”是表名，则权限可以通过设置为零值来引用整个表，或者权限可以通过指定大于零`record_id`的值来引用特定记录。`record_id`授予表权限时，通常在集合中使用权限名称（'create'、'read'、'update'、'delete'、'select'），因为这些权限是可以理解的并且可以由 CRUD 强制执行蜜蜂。

如果`group_id`为零，则 web2py 使用与当前登录用户唯一关联的组。

您还可以使用`auth.id_group(role="...")`给定名称来获取组的 id。



```
auth.del_permission(group_id, 'name', 'object', record_id)
```

撤销许可。

```
auth.has_permission('name', 'object', record_id, user_id)
```

检查由 标识的用户是否在`user_id`具有请求权限的组中具有成员资格。

```
rows = db(auth.accessible_query('read', db.mytable, user_id))    .select(db.mytable.ALL)     
```

`user_id`返回用户具有“读取”权限的表“mytable”的所有行。如果`user_id`未指定，则 web2py 假定当前登录用户。`accessible_query(...)`可以与其他查询组合以生成更复杂的查询。`accessible_query(...)`是唯一需要 JOIN 的**Auth**方法，因此它不适用于 Google App Engine。

假设以下定义：

```
>>> from gluon.tools import Auth
>>> auth = Auth(db)
>>> auth.define_tables()
>>> secrets = db.define_table('secret_document', Field('body'))
>>> james_bond = db.auth_user.insert(first_name='James',
                                     last_name='Bond')           
```

这是一个例子：

```
>>> doc_id = db.secret_document.insert(body = 'top secret')
>>> agents = auth.add_group(role = 'Secret Agent')
>>> auth.add_membership(agents, james_bond)
>>> auth.add_permission(agents, 'read', secrets)
>>> print auth.has_permission('read', secrets, doc_id, james_bond)
True
>>> print auth.has_permission('update', secrets, doc_id, james_bond)
False
```



#### 装饰器

检查权限的最常见方法不是显式调用上述方法，而是通过装饰函数，以便相对于登录的访问者检查权限。这里有些例子：

```
def function_one():
    return 'this is a public function'

@auth.requires_login()
def function_two():
    return 'this requires login'

@auth.requires_membership('agents')
def function_three():
    return 'you are a secret agent'

@auth.requires_permission('read', secrets)
def function_four():
    return 'you can read secret documents'

@auth.requires_permission('delete', 'any file')
def function_five():
    import os
    for file in os.listdir('./'):
        os.unlink(file)
    return 'all files deleted'

@auth.requires(auth.user_id==1 or request.client=='127.0.0.1', requires_login=True)
def function_six():
    return 'you can read secret documents'

@auth.requires_permission('add', 'number')
def add(a, b):
    return a + b

def function_seven():
    return add(3, 4)
```

的条件参数`@auth.requires(condition)`可以是可调用的，除非条件很简单，否则最好传递可调用而不是条件，因为这样会更快，因为只有在需要时才会评估条件。例如

```
@auth.requires ( lambda :  check_condition ()) 
def  action (): 
    ....
```

`@auth.requires`还接受一个可选参数`requires_login`，默认为`True`. 如果设置为 False，则在将条件评估为真/假之前不需要登录。条件可以是布尔值或计算为布尔值的函数。

请注意，对除第一个功能之外的所有功能的访问受到限制，具体取决于访问者可能拥有或不拥有的权限。

如果访问者未登录，则无法查看权限；访问者被重定向到登录页面，然后返回到需要权限的页面。



#### 结合需求

偶尔需要结合需求。这可以通过一个通用`requires`装饰器来完成，它接受一个参数，一个真或假条件。例如，要授予代理访问权限，但仅限于周二：

```
@auth.requires(auth.has_membership(group_id='agents')               and request.now.weekday()==1)
def function_seven():
    return 'Hello agent, it must be Tuesday!'
```

或等效地：

```
@auth.requires(auth.has_membership(role='Secret Agent')                and request.now.weekday()==1)
def function_seven():
    return 'Hello agent, it must be Tuesday!'
```



#### 授权和 CRUD

使用装饰器和/或显式检查提供了一种实现访问控制的方法。

实现访问控制的另一种方法是始终使用 CRUD（而不是`SQLFORM`）来访问数据库，并要求 CRUD 对数据库表和记录实施访问控制。这是通过`Auth`使用以下语句链接和 CRUD 来完成的：

```
crud.settings.auth = auth
```

这将阻止访问者访问任何 CRUD 功能，除非访问者已登录并具有明确的访问权限。例如，允许访问者发表评论，但只更新他们自己的评论（假设定义了 crud、auth 和 db.comment）：

```
def give_create_permission(form):
    group_id = auth.id_group('user_%s' % auth.user.id)
    auth.add_permission(group_id, 'read', db.comment)
    auth.add_permission(group_id, 'create', db.comment)
    auth.add_permission(group_id, 'select', db.comment)

def give_update_permission(form):
    comment_id = form.vars.id
    group_id = auth.id_group('user_%s' % auth.user.id)
    auth.add_permission(group_id, 'update', db.comment, comment_id)
    auth.add_permission(group_id, 'delete', db.comment, comment_id)

auth.settings.register_onaccept = give_create_permission
crud.settings.auth = auth

def post_comment():
   form = crud.create(db.comment, onaccept=give_update_permission)
   comments = db(db.comment).select()
   return dict(form=form, comments=comments)

def update_comment():
   form = crud.update(db.comment, request.args(0))
   return dict(form=form)
```

您还可以选择特定记录（您有“读取”权限的记录）：

```
def post_comment():
   form = crud.create(db.comment, onaccept=give_update_permission)
   query = auth.accessible_query('read', db.comment, auth.user.id)
   comments = db(query).select(db.comment.ALL)
   return dict(form=form, comments=comments)
```

强制执行的权限名称：

```
crud.settings.auth = auth
```

是“读取”、“创建”、“更新”、“删除”、“选择”、“模拟”。



#### 授权和下载

装饰器的使用和`crud.settings.auth`对通常下载功能下载的文件不强制授权的使用

```
def download(): return response.download(request, db)
```

如果希望这样做，必须明确声明哪些“上传”字段包含下载时需要访问控制的文件。例如：

```
db.define_table('dog',
   Field('small_image', 'upload'),
   Field('large_image', 'upload'))

db.dog.large_image.authorize = lambda record:    auth.is_logged_in() and    auth.has_permission('read', db.dog, record.id, auth.user.id)
```

上传字段的属性`authorize`可以是 None （默认）或决定用户是否登录并有权“读取”当前记录的功能。在这个例子中，对“small_image”字段链接的图片的下载没有限制，但我们需要对“large_image”字段链接的图片进行访问控制。





#### 访问控制和基本身份验证

有时，可能需要将具有需要访问控制的装饰器的操作公开为服务；即，从程序或脚本调用它们并且仍然能够使用身份验证来检查授权。

**Auth**通过基本身份验证启用登录：

```
auth.settings.allow_basic_login = True
```

有了这个集合，一个动作就像

```
@auth.requires_login()
def give_me_time():
    import time
    return time.ctime()
```

例如，可以从 shell 命令调用：

```
wget --user=[username] --password=[password] --auth-no-challenge
    http://.../[app]/[controller]/give_me_time
```

也可以通过调用`auth.basic()`而不是使用`@auth`装饰器来登录：

```
def give_me_time():
    import time
    auth.basic()
    if auth.user:
        return time.ctime()
    else:
        return 'Not authorized'
```

基本登录通常是服务的唯一选项（将在下一章中介绍），但默认情况下它是禁用的。



#### 通过特权用户进行应用程序管理（实验）

通常，定义用户和组等管理员功能由服务器管理员管理。但是，您可能希望一组特权用户拥有特定应用程序的管理员权限。这对于 web2py v2.5.1 之后的版本是可能的（升级现有应用程序需要新的 appadmin 控制器和新的 appadmin.html 视图，从欢迎应用程序复制。此外，在 web2py v2.6 之前创建的应用程序需要新的 javascript 文件欢迎/静态/js/web2py.js）

这个概念允许不同的管理设置，每一个都允许一个用户组在这个应用程序中编辑一组特定的表。

示例：首先，为您的特权用户创建一个组（也称为角色）。在本例中，它将被称为 admin。授予此角色的用户成员资格。其次，想一个名称来描述这个管理设置，例如 db_admin。

在您创建和配置身份验证对象的模型中添加以下设置（可能在模型数据库中）：

```
auth.settings.manager_actions = dict(db_admin=dict(role='admin', heading='Manage Database', tables = db.tables))
```

菜单项的 URL 如下所示，将管理设置名称作为 arg 传递：

```
URL （'appadmin' ， 'manage' ， args = [ 'db_admin' ]）
```

此 URL 显示为 /appadmin/manage/auth。

##### 高级使用

该机制允许多种管理设置；每个额外的管理设置只是 auth.settings.manager_actions 中定义的另一个键。

例如，您可能希望一组用户（如“Super”）有权访问名为“db_admin”的管理设置中的每个表，而另一组（如“Content Manager”）有权访问相关表到名为“content_admin”的管理设置中的内容。

可以这样设置：

```
auth.settings.manager_actions = dict(
    db_admin=dict(role='Super', heading='Manage Database', tables=db.tables),
    content_admin=dict(role='Content Manager', tables=[content_db.articles, content_db.recipes, content_db.comments])
    content_mgr_group_v2 = dict(role='Content Manager v2', db=content_db,
        tables=['articles', 'recipes', 'comments'],
        smartgrid_args=dict(
           DEFAULT=dict(maxtextlength=50, paginate=30),
           comments=dict(maxtextlength=100, editable=False)
        )
     )
```

（标题键是可选的。如果缺少，将使用智能默认值）

然后，您可以使用这些 URL 创建两个新菜单项：

```
URL ( 'appadmin' ,  'manage' ,  args = [ 'db_admin' ]) 
URL ( 'appadmin' ,  'manage' ,  args = [ 'content_admin' ])
```

名为“content_mgr_group_v2”的管理设置显示了一些更高级的可能性。键 smartgrid_args 被传递给用于编辑或查看表的 smartgrid。除了特殊键 DEFAULT 之外，表名作为键传递（例如名为“comments”的表）。此示例中的语法将表命名为字符串列表，使用键 db=content_db 来指定数据库。



#### 手动认证

有时您想实现自己的逻辑并进行“手动”用户登录。这也可以通过调用函数来完成：

```
user = auth.login_bare(username, password)
```

`login_bare`如果用户存在且密码有效，则返回用户，否则返回 False。`username`如果“auth_user”表没有“用户名”字段，则为电子邮件。



#### 身份验证设置和消息

这是可以为**Auth自定义的所有参数的列表**

以下必须指向`gluon.tools.Mail`允许`auth`发送电子邮件的对象：

```
auth.settings.mailer = None
```

在此处阅读有关设置邮件的更多信息：[邮件和身份验证](http://web2py.com/books/default/chapter/29/09/access-control#mail_and_auth)

以下必须是定义`user`操作的控制器的名称：

```
auth.settings.controller = 'default'
```

以下是旧 web2py 版本中非常重要的设置：

```
auth.settings.hmac_key = None
```

它被设置为“sha512:a-pass-phrase”之类的东西，并传递给`auth_user`表的“password”字段的 CRYPT 验证器，提供用于散列密码的算法和 a-pass-phrase。但是，web2py 不再需要此设置，因为它会自动处理此设置。

默认情况下，auth 还要求最小密码长度为 4。这可以更改：

```
auth.settings.password_min_length = 4
```

要禁用操作，请将其名称附加到此列表中：

```
auth.settings.actions_disabled = []
```

例如：

```
auth.settings.actions_disabled.append('register')
```

将禁用注册。

如果您想收到一封电子邮件以验证注册，请将其设置为`True`：

```
auth.settings.registration_requires_verification = False
```

要在注册后自动登录人员，即使他们尚未完成电子邮件验证过程，请将以下设置为`True`：

```
auth.settings.login_after_registration = False
```

如果新注册者必须等待批准才能登录，请将其设置为`True`：

```
auth.settings.registration_requires_approval = False
```

批准包括`registration_key==''`通过 appadmin 或以编程方式进行设置。

如果您不希望每个新用户都有一个新组，请将以下设置为`False`：

```
auth.settings.create_user_groups = True
```

如前所述，以下设置确定替代登录方法和登录表单：

```
auth.settings.login_methods = [auth]
auth.settings.login_form = auth
```

您要允许基本登录吗？

```
auth.settings.allows_basic_login = False
```

以下是`login`操作的 URL：

```
auth.settings.login_url = URL('user', args='login')
```

如果用户试图访问注册页面但已经登录，他将被重定向到这个 URL：

```
auth.settings.logged_url = URL('user', args='profile')
```

这必须指向下载操作的 URL，以防配置文件包含图像：

```
auth.settings.download_url = URL('download')
```

这些必须指向您希望在各种可能的操作之后将用户重定向到的 URL `auth`（如果没有引荐来源网址）：

注意：如果您的应用基于标准的脚手架应用 Welcome，则使用 auth.navbar。要使以下设置生效，您需要编辑 layout.html 并设置参数 referrer_actions = None。auth.navbar(mode='dropdown', referrer_actions=None)

也可以为某些身份验证事件保留 referrer_actions。例如

```
auth.navbar(referrer_actions=['login', 'profile'])
```

如果默认行为保持不变，auth.navbar 使用 _next URL 参数，并使用该参数将用户发送回引用页面。但是，如果更改导航栏的默认自动引用行为，则以下设置将生效。

```
auth.settings.login_next = URL('index')
auth.settings.logout_next = URL('index')
auth.settings.profile_next = URL('index')
auth.settings.register_next = URL('user', args='login')
auth.settings.retrieve_username_next = URL('index')
auth.settings.retrieve_password_next = URL('index')
auth.settings.change_password_next = URL('index')
auth.settings.request_reset_password_next = URL('user', args='login')
auth.settings.reset_password_next = URL('user', args='login')
auth.settings.verify_email_next = URL('user', args='login')
```

如果访问者未登录，并调用需要身份验证的函数，则用户将被重定向到`auth.settings.login_url`默认为`URL('default', 'user/login')`. 可以通过重新定义来替换这种行为：

```
auth.settings.on_failed_authentication = lambda url: redirect(url)
```

这是为重定向调用的函数。传递给此函数的参数`url`` 是登录页面的 url。

如果访问者没有访问给定功能的权限，则访问者将被重定向到由定义的 URL

```
auth.settings.on_failed_authorization =     URL('user', args='on_failed_authorization')
```

您可以更改此变量并将用户重定向到其他地方。

通常`on_failed_authorization`是一个 URL，但它可以是一个返回 URL 的函数，它将在授权失败时调用。

这些是在任何数据库 IO 之前的每个相应操作的表单验证之后应执行的回调列表：

```
auth.settings.login_onvalidation = []
auth.settings.register_onvalidation = []
auth.settings.profile_onvalidation = []
auth.settings.retrieve_password_onvalidation = []
auth.settings.reset_password_onvalidation = []
```

每个回调必须是一个接受`form`对象的函数，并且它可以在执行数据库 IO 之前修改表单对象的属性。

这些是在执行数据库 IO 之后和重定向之前应该执行的回调列表：

```
auth.settings.login_onaccept = []
auth.settings.register_onaccept = []
auth.settings.profile_onaccept = []
auth.settings.verify_email_onaccept = []
```

这是一个例子：

```
auth.settings.register_onaccept.append(lambda form:   mail.send(to='you@example.com', subject='new user',
             message='new user email is %s'%form.vars.email))
```

您可以为任何操作启用验证码`auth`：

```
auth.settings.captcha = None
auth.settings.login_captcha = None
auth.settings.register_captcha = None
auth.settings.retrieve_username_captcha = None
auth.settings.retrieve_password_captcha = None
```

如果`.captcha`设置指向 a `gluon.tools.Recaptcha`，则所有设置了相应选项（如`.login_captcha`）的表单`None`都有验证码，而设置了相应选项的表单`False`则没有。相反，如果`.captcha`设置为`None`，则只有那些将相应选项设置为`gluon.tools.Recaptcha`对象的表单将具有验证码，而其他表单则不会。

这是登录会话到期时间：

```
auth.settings.expiration = 3600  # seconds
```

您可以更改密码字段的名称（例如在 Firebird 中，“密码”是关键字，不能用于命名字段）：

```
auth.settings.password_field = 'password'
```

通常登录表单会尝试验证电子邮件。这可以通过更改此设置来禁用：

```
auth.settings.login_email_validate = True
```

您想在编辑个人资料页面中显示记录 ID 吗？

```
auth.settings.showid = False
```

对于自定义表单，您可能希望禁用表单中的自动错误通知：

```
auth.settings.hideerror = False
```

同样对于自定义表单，您可以更改样式：

```
auth.settings.formstyle = 'table3cols'
```

（可以是“bootstrap3_inline”、“table3cols”、“table2cols”、“divs”和“ul”；有关所有选项，请参见 gluon/sqlhtml.py）

您可以为身份验证生成的表单设置分隔符：

```
auth.settings.label_separator =        ':'
```

默认情况下，登录表单提供通过“记住我”选项扩展登录的选项。可以通过以下设置更改到期时间或禁用该选项：

```
auth.settings.long_expiration = 3600*24*30 # one month
auth.settings.remember_me_form = True
```

您还可以自定义以下消息，其用途和上下文应该是显而易见的：

```
auth.messages.submit_button = 'Submit'
auth.messages.verify_password = 'Verify Password'
auth.messages.delete_label = 'Check to delete:'
auth.messages.function_disabled = 'Function disabled'
auth.messages.access_denied = 'Insufficient privileges'
auth.messages.registration_verifying = 'Registration needs verification'
auth.messages.registration_pending = 'Registration is pending approval'
auth.messages.login_disabled = 'Login disabled by administrator'
auth.messages.logged_in = 'Logged in'
auth.messages.email_sent = 'Email sent'
auth.messages.unable_to_send_email = 'Unable to send email'
auth.messages.email_verified = 'Email verified'
auth.messages.logged_out = 'Logged out'
auth.messages.registration_successful = 'Registration successful'
auth.messages.invalid_email = 'Invalid email'
auth.messages.unable_send_email = 'Unable to send email'
auth.messages.invalid_login = 'Invalid login'
auth.messages.invalid_user = 'Invalid user'
auth.messages.is_empty = "Cannot be empty"
auth.messages.mismatched_password = "Password fields don't match"
auth.messages.verify_email = ...
auth.messages.verify_email_subject = 'Password verify'
auth.messages.username_sent = 'Your username was emailed to you'
auth.messages.new_password_sent = 'A new password was emailed to you'
auth.messages.password_changed = 'Password changed'
auth.messages.retrieve_username = 'Your username is: %(username)s'
auth.messages.retrieve_username_subject = 'Username retrieve'
auth.messages.retrieve_password = 'Your password is: %(password)s'
auth.messages.retrieve_password_subject = 'Password retrieve'
auth.messages.reset_password = ...
auth.messages.reset_password_subject = 'Password reset'
auth.messages.invalid_reset_password = 'Invalid reset password'
auth.messages.profile_updated = 'Profile updated'
auth.messages.new_password = 'New password'
auth.messages.old_password = 'Old password'
auth.messages.group_description =     'Group uniquely assigned to user %(id)s'
auth.messages.register_log = 'User %(id)s Registered'
auth.messages.login_log = 'User %(id)s Logged-in'
auth.messages.logout_log = 'User %(id)s Logged-out'
auth.messages.profile_log = 'User %(id)s Profile updated'
auth.messages.verify_email_log = 'User %(id)s Verification email sent'
auth.messages.retrieve_username_log = 'User %(id)s Username retrieved'
auth.messages.retrieve_password_log = 'User %(id)s Password retrieved'
auth.messages.reset_password_log = 'User %(id)s Password reset'
auth.messages.change_password_log = 'User %(id)s Password changed'
auth.messages.add_group_log = 'Group %(group_id)s created'
auth.messages.del_group_log = 'Group %(group_id)s deleted'
auth.messages.add_membership_log = None
auth.messages.del_membership_log = None
auth.messages.has_membership_log = None
auth.messages.add_permission_log = None
auth.messages.del_permission_log = None
auth.messages.has_permission_log = None
auth.messages.label_first_name = 'First name'
auth.messages.label_last_name = 'Last name'
auth.messages.label_username = 'Username'
auth.messages.label_email = 'E-mail'
auth.messages.label_password = 'Password'
auth.messages.label_registration_key = 'Registration key'
auth.messages.label_reset_password_key = 'Reset Password key'
auth.messages.label_registration_id = 'Registration identifier'
auth.messages.label_role = 'Role'
auth.messages.label_description = 'Description'
auth.messages.label_user_id = 'User ID'
auth.messages.label_group_id = 'Group ID'
auth.messages.label_name = 'Name'
auth.messages.label_table_name = 'Table name'
auth.messages.label_record_id = 'Record ID'
auth.messages.label_time_stamp = 'Timestamp'
auth.messages.label_client_ip = 'Client IP'
auth.messages.label_origin = 'Origin'
auth.messages.label_remember_me = "Remember me (for 30 days)"
```

`add|del|has`会员日志允许使用“%(user_id)s”和“%(group_id)s”。`add|del|has`权限日志允许使用“%(user_id)s”、“%(name)s”、“%(table_name)s”和“%(record_id)s”。



### 中央认证服务 central authentication service





web2py 提供对第三方身份验证和单点登录的支持。在这里，我们讨论了中央身份验证服务（CAS），它是一种行业标准，客户端和服务器都内置在 web2py 中。

CAS 是分布式身份验证的开放协议，它的工作方式如下：当访问者到达我们的网站时，如果用户已经通过身份验证（例如通过`session.token`对象），我们的应用程序会检查会话。如果用户未通过身份验证，控制器会将访问者从 CAS 设备重定向，用户可以在其中登录、注册和管理其凭据（姓名、电子邮件和密码）。如果用户注册，他会收到一封电子邮件，并且在他回复电子邮件之前，注册是不完整的。用户成功注册并登录后，CAS 设备会将用户连同密钥一起重定向到我们的应用程序。我们的应用程序使用密钥通过后台向 CAS 服务器发送 HTTP 请求获取用户的凭据。

使用这种机制，多个应用程序可以通过单个 CAS 服务器使用单点登录。提供认证的服务器称为服务提供者。寻求对访问者进行身份验证的应用程序称为服务消费者。

CAS 类似于 OpenID，但有一个主要区别。在 OpenID 的情况下，访问者选择服务提供者。在 CAS 的情况下，我们的应用程序做出了这个选择，使 CAS 更加安全。

运行 web2py CAS 提供程序就像复制脚手架应用程序一样简单。事实上，任何暴露动作的 web2py 应用程序

```
## in provider app
def user(): return dict(form=auth())
```

是 CAS 2.0 提供者，可以通过 URL 访问其服务

```
http://.../provider/default/user/cas/login
http://.../provider/default/user/cas/validate
http://.../provider/default/user/cas/logout
```

（我们假设应用程序被称为“提供者”）。

只需将身份验证委托给提供者，您就可以从任何其他 Web 应用程序（消费者）访问此服务：

```
## in consumer app
auth = Auth(db, cas_provider='http://127.0.0.1:8000/provider/default/user/cas')
```

当您访问消费者应用程序的登录 url 时，它会将您重定向到提供者应用程序，该应用程序将执行身份验证并将重定向回消费者。注册、注销、更改密码、找回密码的所有过程都必须在提供商应用程序上完成。将在消费者端创建有关登录用户的条目，以便您添加额外的字段并拥有本地配置文件。`auth_user`多亏了 CAS 2.0，所有在提供者上可读并且在消费者表中具有相应字段的字段都将被自动复制。

`Auth(..., cas_provider='...')`与第三方提供商合作并支持 CAS 1.0 和 2.0。自动检测版本。默认情况下，它`cas_provider`通过附加从基础（上面的 url）构建提供程序的 URL

```
/login
/validate
/logout
```

这些可以在消费者和提供者中更改

```
## in consumer or provider app (must match)
auth.settings.cas_actions['login']='login'
auth.settings.cas_actions['validate']='validate'
auth.settings.cas_actions['logout']='logout'
```

如果您想从不同的域连接到 web2py CAS 提供程序，您必须通过附加到允许的域列表来启用它们：

```
## in provider app
auth.settings.cas_domains.append('example.com')
```



#### 使用 web2py 授权非 web2py 应用

这是可能的，但取决于 Web 服务器。在这里，我们假设两个应用程序在同一个 Web 服务器下运行：Apache 和`mod_wsgi`. 其中一个应用程序是 web2py，它带有一个通过 Auth 证明访问控制的应用程序。另一个可以是 CGI 脚本、PHP 程序或其他任何东西。当客户端请求访问前一个应用程序时，我们希望指示 Web 服务器向前一个应用程序请求权限。

首先我们需要修改 web2py 应用程序并添加以下控制器：

```
def check_access():
    return 'true' if auth.is_logged_in() else 'false' 
```

`true`如果用户登录则返回，`false`否则返回。现在在后台运行一个 web2py 进程：

```
nohup python web2py.py -a '' -p 8002
```

端口 8002 是必须的，不需要启用管理员，所以没有管理员密码。

然后我们需要编辑 Apache 配置文件（例如“/etc/apache2/sites-available/default”）并指示 apache，以便在调用非 web2py 程序时，它应该调用上述`check`操作，并且只有当它返回`true`它应该继续并响应请求，否则如果应该拒绝访问。

因为 web2py 和非 web2py 应用程序运行在同一个域下，如果用户登录到 web2py 应用程序，即使请求其他应用程序，web2py 会话 cookie 也会传递给 Apache，并允许凭据验证。

为了实现这一点，我们需要一个脚本“web2py/scripts/access.wsgi”来发挥这个作用。该脚本随 web2py 一起提供。我们需要做的就是告诉 apache 调用这个脚本、需要访问控制的应用程序的 URL 以及脚本的位置：

```
<VirtualHost *:80>
   WSGIDaemonProcess web2py user=www-data group=www-data
   WSGIProcessGroup web2py
   WSGIScriptAlias / /home/www-data/web2py/wsgihandler.py

   AliasMatch ^myapp/path/needing/authentication/myfile /path/to/myfile
   <Directory /path/to/>
     WSGIAccessScript /path/to/web2py/scripts/access.wsgi
   </Directory>
</VirtualHost>
```

这里“^myapp/path/needing/authentication/myfile”是应该匹配传入请求的正则表达式，“/path/to/”是 web2py 文件夹的绝对位置。

“access.wsgi”脚本包含以下行：

```
URL_CHECK_ACCESS = 'http://127.0.0.1:8002/%(app)s/default/check_access'
```

它指向我们请求的 web2py 应用程序，但您可以对其进行编辑以指向特定应用程序，该应用程序在 8002 以外的端口上运行。

您还可以更改`check_access()`操作并使其逻辑更复杂。此操作可以检索使用环境变量最初请求的 URL

```
request.env.request_uri
```

你可以实现更复杂的规则：

```
def check_access():
    if not auth.is_logged_in():
       return 'false'
    elif not user_has_access(request.env.request_uri):
       return 'false'
    else:
       return 'true'
```