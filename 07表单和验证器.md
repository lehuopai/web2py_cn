## 表单和验证器[¶](http://web2py.com/books/default/chapter/29/07/forms-and-validators#Forms-and-validators)

在 web2py 中构建表单有四种不同的方法：

- `FORM`在 HTML 帮助器方面提供了一个低级实现。一个`FORM`对象可以被序列化为 HTML 并且知道它包含的字段。`FORM`对象知道如何验证提交的表单值。
- `SQLFORM`提供了一个高级 API，用于从现有数据库表中创建、更新和删除表单。
- `SQLFORM.factory`是一个抽象层，`SQLFORM`即使不存在数据库，也可以利用表单生成功能。它生成一个与表描述非常相似`SQLFORM`的表格，但不需要创建数据库表。
- `CRUD`方法。它们在功能上等同于 SQLFORM 并且基于 SQLFORM，但提供了更紧凑的表示法；`CRUD`现在已弃用，取而代之的是`SQLFORM.grid()`and `SQLFORM.smartgrid()`。

所有这些表单都是自我感知的，如果输入未通过验证，它们可以自行修改并添加错误消息。可以在表单中查询已验证的变量和已通过验证生成的错误消息。

可以使用帮助器将任意 HTML 代码插入或从表单中提取。

`FORM`并且`SQLFORM`是助手，它们可以以与`DIV`. 例如，您可以设置表单样式：

```
form = SQLFORM(..)
form['_style']='border:1px solid black'
```



### `FORM`





以具有以下“default.py”控制器的**测试**应用程序为例：

```
def display_form():
    form = FORM('Your name:', INPUT(_name='name'), INPUT(_type='submit'))
    return dict(form=form) 
```

以及相关的“default/display_form.html”视图：

```
{{extend 'layout.html'}}
<h2>Input form</h2>
<form enctype="multipart/form-data"
      action="{{=URL()}}" method="post">
Your name:
<input name="name" />
<input type="submit" />
</form>
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
```

这是一个询问用户姓名的常规 HTML 表单。当您填写表单并单击提交按钮时，表单会自行提交，并且变量`request.vars.name`及其提供的值会显示在底部。

您可以使用助手生成相同的表单。这可以在视图或动作中完成。由于 web2py 在 action 中处理了表单，所以最好在 action 本身中定义表单。

这是新的控制器：

```
def display_form():
   form=FORM('Your name:', INPUT(_name='name'), INPUT(_type='submit'))
   return dict(form=form)
```

以及相关的“default/display_form.html”视图：

```
{{extend 'layout.html'}}
<h2>Input form</h2>
{{=form}}
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
```

到目前为止的代码与前面的代码等效，但表单是由`{{=form}}`序列化`FORM`对象的语句生成的。

现在我们通过添加表单验证和处理来增加一层复杂性。

更改控制器如下：

```
def display_form():
    form=FORM('Your name:',
              INPUT(_name='name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.accepts(request, session):
        response.flash = 'form accepted'
    elif form.errors:
        response.flash = 'form has errors'
    else:
        response.flash = 'please fill the form'
    return dict(form=form)
```

以及相关的“default/display_form.html”视图：

```
{{extend 'layout.html'}}
<h2>Input form</h2>
{{=form}}
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
<h2>Accepted variables</h2>
{{=BEAUTIFY(form.vars)}}
<h2>Errors in form</h2>
{{=BEAUTIFY(form.errors)}}
```

请注意：

- 在操作中，我们`requires=IS_NOT_EMPTY()`为输入字段“名称”添加了验证器。
- 在动作中，我们添加了一个调用`form.accepts(..)`
- 在视图中，我们正在打印`form.vars`和`form.errors`以及表单和`request.vars`。

所有的工作都是通过对象的`accepts`方法来完成的`form`。它`request.vars`根据声明的要求（由验证器表示）过滤。`accepts`将那些通过验证的变量存储到`form.vars`. 如果字段值不满足要求，则失败的验证器会返回错误并将错误存储在`form.errors`. `form.vars`和都是类似于`form.errors`的对象。前者包含通过验证的值，例如：`gluon.storage.Storage``request.vars`

```
form.vars.name = "Max"
```

后者包含错误，例如：

```
form.errors.name = "Cannot be empty!"
```

该`accepts`方法的完整签名如下：

```
form.accepts(vars, session=None, formname='default',
             keepvalues=False, onvalidation=None,
             dbio=True, hideerror=False):
```

可选参数的含义将在接下来的小节中解释。

第一个参数可以是`request.vars`or`request.get_vars`或`request.post_vars`or `request`。后者相当于接受`request.post_vars`.

如果表单被接受，则`accepts` 函数返回，否则返回。如果表单有错误或尚未提交（例如，第一次显示），则不接受表单。`True``False`

这是此页面第一次显示时的外观：



![图片](http://web2py.com/books/default/image/29/en5800.png)



以下是无效提交时的外观：



![图片](http://web2py.com/books/default/image/29/en5900.png)



以下是它对有效提交的看法：



![图片](http://web2py.com/books/default/image/29/en6000.png)





#### `process`和`validate`方法_

一个快捷方式

```
form.accepts(request.post_vars, session, ...)
```

是

```
form.process(...).accepted
```

后者不需要`request`and`session`参数（尽管您可以选择指定它们）。它也不同，`accepts`因为它返回表单本身。内部`process`调用接受并将其参数传递给它。accept 返回的值存储在`form.accepted`.

process 函数需要一些额外的参数，`accepts`而不需要：

- `message_onsuccess`
- `onsuccess`：如果等于'flash'（默认）并且表单被接受，它将闪烁上面`message_onsuccess`
- `message_onfailure`
- `onfailure`：如果等于'flash'（默认）并且表单验证失败，它将闪烁上面`message_onfailure`
- `next`指示在接受表单后将用户重定向到哪里。

`onsuccess`并且`onfailure`可以是`lambda form: do_something(form)`.

```
form.validate(...)
```

是一个捷径

```
form.process(..., dbio=False).accepted
```



#### 条件字段

有时您只希望在满足条件时显示字段。例如，考虑以下模型：

```
db.define_table('purchase', Field('have_coupon', 'boolean'), Field('coupon_code'))
```

`coupon_code`当且仅当该`have_coupon`字段被选中时，您才希望显示该字段。这可以在 JavaScript 中完成。web2py 可以通过为您生成 JavaScript 来帮助您。您只需要声明该字段是使用 field`show_if`属性的表达式的条件：

```
def index():
    db.purchase.coupon_code.show_if = (db.purchase.have_coupon==True)
    form = SQLFORM(db.purchase).process()
    return dict(form = form)
```

的值`show_if`是一个查询，使用与数据库查询相同的 DAL 语法。不同之处在于，此查询不会发送到数据库，而是会转换为 JavaScript 并发送到浏览器，并在用户编辑表单时在浏览器中执行。



#### 隐藏字段

当上面的表单对象被 序列化时`{{=form}}`，由于之前调用了该`accepts`方法，它现在看起来像这样：

```
<form enctype="multipart/form-data" action="" method="post">
your name:
<input name="name" />
<input type="submit" />
<input value="783531473471" type="hidden" name="_formkey" />
<input value="default" type="hidden" name="_formname" />
</form>
```

注意两个隐藏字段的存在：“_formkey”和“_formname”。他们的存在是由调用触发的`accepts`，他们扮演两个不同且重要的角色：

- 名为“_formkey”的隐藏字段是 web2py 用来防止重复提交表单的一次性令牌。当表单被序列化并存储在`session`. 提交表单时，此值必须匹配，否则`accepts`返回`False`没有错误，就好像根本没有提交表单一样。这是因为 web2py 无法判断表单是否正确提交。
- web2py 生成名为“_formname”的隐藏字段作为表单的名称，但该名称可以被覆盖。此字段对于允许包含和处理多个表单的页面是必需的。web2py 通过名称区分不同提交的表单。
- 指定为 的可选隐藏字段`FORM(..., hidden=dict(...))`。

这些隐藏字段的作用及其在自定义表单和具有多个表单的页面中的使用将在本章后面更详细地讨论。

如果上述表单提交时“名称”字段为空，则该表单未通过验证。当表单再次序列化时，它显示为：

```
<form enctype="multipart/form-data" action="" method="post">
your name:
<input value="" name="name" />
<div class="error">cannot be empty!</div>
<input type="submit" />
<input value="783531473471" type="hidden" name="_formkey" />
<input value="default" type="hidden" name="_formname" />
</form>
```

请注意序列化形式中存在类“错误”的 DIV。web2py 在表单中插入此错误消息以通知访问者有关未通过验证的字段。该`accepts`方法在提交时确定表单已提交，检查“name”字段是否为空以及是否需要，并最终将来自验证器的错误消息插入到表单中。

基本的“layout.html”视图应处理“错误”类的 DIV。默认布局使用jQuery效果使错误出现并以红色背景向下滑动。有关详细信息，请参阅[第 11 章。](http://web2py.com/books/default/chapter/29/11#web2py_ajax-html)



#### `keepvalues`

可选参数`keepvalues`告诉 web2py 当表单被接受并且没有重定向时要做什么，因此再次显示相同的表单。默认情况下，表单被清除。如果`keepvalues`设置为`True`，则表单会预先填充先前插入的值。当您有一个应该重复使用以插入多个相似记录的表单时，这很有用。



#### `dbio`

如果`dbio`参数设置为`False`，web2py 在接受表单后不会执行任何数据库插入/更新。



#### `hideerror`

如果`hideerror`设置为`True`并且表单包含错误，则在呈现表单时将不会显示这些错误（取决于您以`form.errors`某种方式显示它们）。



#### `onvalidation`

`onvalidation`参数可以是`None`或可以是采用形式并且不返回任何内容的函数。这样的函数将在验证之后（如果验证通过）和其他任何事情发生之前立即被调用并传递给表单。此函数有多种用途：例如，对表单进行额外检查并最终将错误添加到表单中，或者根据其他字段的值计算某些字段的值，或者触发某些操作（例如发送电子邮件） ) 在创建/更新记录之前。

这是一个例子：

```
db.define_table('numbers',
    Field('a', 'integer'),
    Field('b', 'integer'),
    Field('c', 'integer', readable=False, writable=False))

def my_form_processing(form):
    c = form.vars.a * form.vars.b
    if c < 0:
       form.errors.b = 'a*b cannot be negative'
    else:
       form.vars.c = c

def insert_numbers():
   form = SQLFORM(db.numbers)
   if form.process(onvalidation=my_form_processing).accepted:
       session.flash = 'record inserted'
       redirect(URL())
   return dict(form=form)    
       
    
```



#### 检测记录变化

填写表格以编辑记录时，另一个用户可能同时编辑同一记录的可能性很小。因此，当我们保存记录时，我们要检查可能的冲突。可以这样做：

```
db.define_table('dog', Field('name'))

def edit_dog():
    dog = db.dog(request.args(0)) or redirect(URL('error'))
    form=SQLFORM(db.dog, dog)
    form.process(detect_record_change=True)
    if form.record_changed:
        # do something
    elif form.accepted:
        # do something else
    else:
        # do nothing
    return dict(form=form)
```

`record_changed`仅适用于 SQLFORM 而不适用于 FORM。



#### 表单和重定向

使用表单的最常见方式是通过自行提交，以便提交的字段变量由生成表单的相同操作处理。一旦表单被接受，再次显示当前页面是不寻常的（我们在这里做的只是为了简单起见）。将访问者重定向到“下一页”更为常见。

这是新的示例控制器：

```
def display_form():
    form = FORM('Your name:',
              INPUT(_name='name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.process().accepted:
        session.flash = 'form accepted'
        redirect(URL('next'))
    elif form.errors:
        response.flash = 'form has errors'
    else:
        response.flash = 'please fill the form'
    return dict(form=form)

def next():
    return dict()
```

为了在下一页而不是当前页面上设置 flash，您必须使用`session.flash`而不是`response.flash`. web2py 在重定向后将前者移动到后者。请注意，使用`session.flash`要求您不使用`session.forget()`.



#### 每页多个表单

本节内容适用于`FORM`和`SQLFORM`对象。每个页面可以有多个表单，但您必须允许 web2py 区分它们。如果这些是`SQLFORM`从不同的表派生的，那么 web2py 会自动给它们不同的名称；否则你需要明确地给他们不同的表单名称。这是一个例子：

```
def two_forms():
    form1 = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
                 INPUT(_type='submit'), _name='form_one')
    form2 = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
                 INPUT(_type='submit'), _name='form_two')
    if form1.process(formname='form_one').accepted:
        response.flash = 'form one accepted'
    if form2.process(formname='form_two').accepted:
        response.flash = 'form two accepted'
    return dict(form1=form1, form2=form2)
```

这是它产生的输出：



![图片](http://web2py.com/books/default/image/29/en6100.png)



当访问者提交一个空的form1时，只有form1显示错误；如果访问者提交了一个空的 form2，则只有 form2 显示错误消息。



#### 分享表格

本节内容适用于`FORM`和`SQLFORM`对象。我们在这里讨论的内容是可能的，但不建议这样做，因为拥有自行提交的表单始终是一种好习惯。但是，有时您别无选择，因为发送表单的操作和接收表单的操作属于不同的应用程序。

可以生成提交到不同操作的表单。这是通过在`FORM`or`SQLFORM`对象的属性中指定处理操作的 URL 来完成的。例如：

```
form = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
        INPUT(_type='submit'), _action=URL('page_two'))

def page_one():
    return dict(form=form)

def page_two():
    if form.process(session=None, formname=None).accepted:
         response.flash = 'form accepted'
    else:
         response.flash = 'there was an error in the form'
    return dict()
```

请注意，由于 "page_one" 和 "page_two" 都使用相同的`form`，我们只定义了一次，将它放在所有操作之外，以免重复。每次将控制权交给被调用的动作之前，控制器开头的代码的公共部分都会被执行。

由于“page_one”不调用`process`(nor `accepts`)，所以表单没有名字也没有key，所以必须传入 `session=None`并设置`formname=None`，`process`否则“page_two”收到时表单不会生效。



#### 向表单添加按钮

通常一个表单提供一个提交按钮。通常希望添加一个“返回”按钮，而不是提交表单，而是将访问者引导到不同的页面。

这可以通过以下`add_button`方法完成：

```
form.add_button('Back', URL('other_page'))
```

您可以在表单中添加多个按钮。的参数`add_button`是按钮的值（其文本）和重定向到的 url。（另请参阅 SQLFORM 的按钮参数，它提供了更强大的方法）



#### 有关表单操作的更多信息

正如 Views 章节中所讨论的，FORM 是一个 HTML 助手。助手可以作为 Python 列表和字典进行操作，从而可以在运行时创建和修改。



### `SQLFORM`

我们现在通过为应用程序提供模型文件进入下一个级别：

```
db = DAL('sqlite://storage.sqlite')
db.define_table('person', Field('name', requires=IS_NOT_EMPTY()))
```

修改控制器如下：

```
def display_form():
   form = SQLFORM(db.person)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   else:
       response.flash = 'please fill out the form'
   return dict(form=form)
    
```

不需要更改视图。

在新的控制器中，您不需要构建一个`FORM`，因为`SQLFORM`构造函数是从`db.person`模型中定义的表中构建的。这种新形式在序列化后显示为：

```
<form enctype="multipart/form-data" action="" method="post">
  <table>
    <tr id="person_name__row">
       <td><label id="person_name__label"
                  for="person_name">Your name: </label></td>
       <td><input type="text" class="string"
                  name="name" value="" id="person_name" /></td>
       <td></td>
    </tr>
    <tr id="submit_record__row">
       <td></td>
       <td><input value="Submit" type="submit" /></td>
       <td></td>
    </tr>
  </table>
  <input value="9038845529" type="hidden" name="_formkey" />
  <input value="person" type="hidden" name="_formname" />
</form>
```

自动生成的表单比之前的低级表单更复杂。首先，它包含一个行表，每行包含三列。第一列包含字段标签（由 确定`db.person`），第二列包含输入字段（以及最终的错误消息），第三列是可选的，因此为空（可以使用`SQLFORM`构造函数中的字段填充）。

表单中的所有标签都具有从表和字段名称派生的名称。这允许使用 CSS 和 JavaScript 轻松自定义表单。[第 11 章](http://web2py.com/books/default/chapter/29/11#Conditional-fields-in-forms)将更详细地讨论此功能。

更重要的是，现在该`accepts`方法为您做了更多的工作。与前一种情况一样，它执行输入验证，但此外，如果输入通过验证，它还会执行新记录的数据库插入并存储在新记录`form.vars.id`的唯一“id”中。

对象还通过`SQLFORM`将上传的文件保存在“上传”文件夹中（在安全地重命名以避免冲突和防止目录遍历攻击之后）自动处理“上传”字段，并将它们的名称（它们的新名称）存储到适当的字段中数据库。处理完表单后，新文件名在 中可用`form.vars.fieldname`（即，它替换 中的`cgi.FieldStorage`对象`request.vars.fieldname`），因此您可以在上传后轻松引用新名称。

> 警告：默认字段长度为 512 个字符。如果一个人的文件系统不支持这么长的文件名，它可能会生成在尝试创建它们时会导致错误的名称。这可以通过设置`Field(..., length=...)`适当的值来解决。另请注意，这可能会截断原始文件名的编码，并且在下载上传的文件时可能无法恢复它。

A`SQLFORM`显示带有复选框的“布尔”值，带有文本区域的“文本”值，需要在特定集合或带有下拉列表的数据库中的值，以及带有允许用户下载上传文件的链接的“上传”字段。它隐藏了“blob”字段，因为它们应该以不同的方式处理，请参阅第 6 章中[有关上传](http://web2py.com/books/default/chapter/29/06#More-on-uploads)部分的更多示例。

例如，考虑以下模型：

```
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('married', 'boolean'),
    Field('gender', requires=IS_IN_SET(['Male', 'Female', 'Other'])),
    Field('profile', 'text'),
    Field('image', 'upload'))
```

在这种情况下，`SQLFORM(db.person)`生成如下所示的表单：



![图片](http://web2py.com/books/default/image/29/en6200.png)



构造`SQLFORM`函数允许进行各种自定义，例如仅显示字段的子集、更改标签、向可选的第三列添加值或创建 UPDATE 和 DELETE 表单，而不是像当前的 INSERT 表单。`SQLFORM`是 web2py 中最大的单个节省时间的对象。

该类`SQLFORM`在“gluon/sqlhtml.py”中定义。它可以通过覆盖其`xml`方法（序列化对象的方法）轻松扩展，以更改其输出。



`SQLFORM`构造函数的签名如下：



```
SQLFORM(table, record=None,
        deletable=False, linkto=None,
        upload=None, fields=None, labels=None,
        col3={}, submit_button='Submit',
        delete_label='Check to delete',
        showid=True, readonly=False,
        comments=True, keepopts=[],
        ignore_rw=False, record_id=None,
        formstyle='table3cols',
        buttons=['submit'], separator=': ',
        extra_fields=None,
        **attributes)
```

- 可选的第二个参数将 INSERT 表单转换为指定记录的 UPDATE 表单（参见下一小节）。
- 如果`deletable`设置为`True`，则 UPDATE 表单将显示“检查以删除”复选框。该字段的标签值是通过`delete_label`参数设置的。
- `submit_button`设置提交按钮的值。
- `id_label`设置记录“id”的标签
- `showid`如果设置为 ，则不显示记录的“id” `False`。
- `fields`是要显示的字段名称的可选列表。如果提供了列表，则仅显示列表中的字段。例如：

```
fields = ['name']
```

- `labels`是字段标签的字典。字典键是一个字段名称，对应的值是作为其标签显示的内容。如果没有提供标签，web2py 从字段名称派生标签（它将字段名称大写并用空格替换下划线）。例如：

```
labels = {'name':'Your Full Name:'}
```

- `col3`是第三列的值字典。例如：

```
col3 = {'name':A('what is this?',
      _href='http://www.google.com/search?q=define:name')}
```

- `linkto`并且`upload`是允许表单处理引用字段的用户定义控制器的可选 URL。[这将在后面分别在引用记录](http://web2py.com/books/default/chapter/29/07/forms-and-validators#Links-to-referencing-records)和[SQLFORM 和上传](http://web2py.com/books/default/chapter/29/07/forms-and-validators#SQLFORM-and-uploads)部分的链接中更详细地讨论。
- `readonly`. 如果设置为 True，则将表单显示为只读
- `comments`. 如果设置为 False，则不显示 col3 注释
- `ignore_rw`. 通常，对于创建/更新表单，仅显示标记为 writable=True 的字段，而对于只读表单，仅显示标记为 readable=True 的字段。设置`ignore_rw=True`会导致这些约束被忽略，并显示所有字段。这主要在 appadmin 界面中用于显示每个表的所有字段，覆盖模型指示的内容。
- `formstyle`确定在 html 中序列化表单时要使用的样式。默认值来自`response.formstyle`，目前是“bootstrap4_inline”。其他选项是“bootstrap4_stacked”、“bootstrap3_inline”、“bootstrap3_stacked”、“bootstrap2”、“table3cols”、“table2cols”（一行用于标签和注释，一行用于输入）、“ul”（生成输入的无序列表字段）、“divs”（表示使用 css 友好 div 的表单，用于任意自定义）、“bootstrap”，它使用 bootstrap 2.3 表单类“form-horizontal”。`formstyle`也可以是生成 FORM 标签内所有内容的函数。你将两个参数传递给表单构造函数，表单和字段。提示可以在源代码文件 sqlhtml 中找到。
- `buttons``INPUT`是将添加到提交按钮所在的 DIV 的s 或s的列表`BUTTON`（尽管从技术上讲可以是助手的任何组合）。

例如，添加基于 URL 的后退按钮（用于多页表单）和重命名的提交按钮：

```
buttons = [BUTTON('Back', _type="button", _onClick="parent.location='%s'" % URL(...),
           BUTTON('Next', _type="submit")]
```

或链接到另一个页面的按钮：

```
buttons = [..., A("Go to another page", _class='btn', _href=URL("default", "anotherpage"))]
```

- `separator`设置将表单标签与表单输入字段分开的字符串，如果设置为 None 则默认值来自`response.form_label_separator`
- `extra_fields`是要添加的额外`Field`s 的列表。
- 可选`attributes`参数是以下划线开头的参数，您希望传递给`FORM`呈现`SQLFORM`对象的标签。例子是：

```
_action = '.'
_method = 'POST'
```

有一个特殊的`hidden`属性。当字典作为 传递时`hidden`，它的项目被翻译成“隐藏的” INPUT 字段（参见[第 5 章](http://web2py.com/books/default/chapter/29/05#FORM)`FORM`中的帮助器示例）。

```
form = SQLFORM(..., hidden=...)
```

导致隐藏字段与提交一起传递，不多也不少。`form.accepts(...)`不打算读取接收到的隐藏字段并将它们移动到 form.vars 中。原因是安全。隐藏字段可以被篡改。因此，您必须将隐藏字段从请求显式移动到表单：

```
form = SQLFORM(..., hidden=dict(a='b'))
form.vars.a = request.vars.a
```



#### `process`方法_

`SQLFORM`从 继承`process`方法`FORM`。



#### `SQLFORM`和`insert`/`update`/`delete`

`SQLFORM`当表单被接受时创建一个新的数据库记录。假设

```
form = SQLFORM(db.test)
```

，那么最后创建的记录的 id 就可以在`form.vars.id`.



如果将记录作为可选的第二个参数传递给`SQLFORM`构造函数，则表单将成为该记录的 UPDATE 表单。这意味着当提交表单时，现有记录会更新，并且不会插入新记录。如果您设置了参数`deletable=True`，则 UPDATE 表单会显示“检查以删除”复选框。如果选中，则删除记录。

> 如果提交了表单并且选中了删除复选框，则属性`form.deleted`设置为`True`。

您可以修改上一个示例的控制器，以便当我们在 URL 路径中传递一个额外的整数参数时，如下所示：

```
/test/default/display_form/2
```

如果有对应 id 的记录，则为该记录`SQLFORM`生成一个 UPDATE/DELETE 表单：

```
def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   form = SQLFORM(db.person, record)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)
```

第 2 行查找记录，第 3 行生成 UPDATE/DELETE 表单。第 4 行进行所有相应的表单处理。

> 更新表单与创建表单非常相似，只是它预先填充了当前记录并预览图像。默认情况下`deletable = True`，这意味着更新表单将显示“删除记录”选项。

编辑表单还包含一个隐藏的 INPUT 字段，`name="id"`用于标识记录。这个 id 也存储在服务器端以提高安全性，如果访问者篡改了这个字段的值，则不会执行 UPDATE 并且 web2py 会引发 SyntaxError，“用户正在篡改表单”。

当字段被标记时`writable=False`，该字段在创建表单中不显示，并且在更新表单中以只读方式显示。如果一个字段被标记为`writable=False`和`readable=False`，则该字段根本不会显示，即使在更新表单中也不显示。

使用创建的表单

```
form = SQLFORM(..., ignore_rw=True)
```

忽略`readable`and`writable`属性并始终显示所有字段。默认情况下，表单`appadmin`会忽略它们。

使用创建的表单

```
form = SQLFORM(table, record_id, readonly=True)
```

始终以只读模式显示所有字段，并且它们不能被接受。

用 标记字段`writable=False`可防止该字段成为表单的一部分，并导致表单处理`request.vars.field`在处理表单时忽略 的值。但是，如果您为 分配一个值`form.vars.field`，则该值*将*成为处理表单时插入或更新的一部分。这使您能够更改由于某种原因您不希望包含在表单中的字段的值。



#### `SQLFORM`在 HTML 中

有时您希望使用`SQLFORM`它来从其表单生成和处理中受益，但是您需要在 HTML 中对表单进行一定程度的自定义，而这是您无法通过`SQLFORM`对象的参数实现的，因此您必须使用 HTML 来设计表单。

现在，编辑之前的控制器并添加一个新动作：

```
def display_manual_form():
    form = SQLFORM(db.person)
    if form.process(session=None, formname='test').accepted:
        response.flash = 'form accepted'
    elif form.errors:
        response.flash = 'form has errors'
    else:
        response.flash = 'please fill the form'
    # Note: no form instance is passed to the view
    return dict()
```

并在关联的“default/display_manual_form.html”视图中插入表单：

```
{{extend 'layout.html'}}
<form action="#" enctype="multipart/form-data" method="post">
<ul>
  <li>Your name is <input name="name" /></li>
</ul>
  <input type="submit" />
  <input type="hidden" name="_formname" value="test" />
</form>
```

请注意，该操作不会返回表单，因为它不需要将其传递给视图。该视图包含一个用 HTML 手动创建的表单。表单包含一个隐藏字段“_formname”，该字段必须与操作`formname`中的参数指定的相同`accepts`。如果同一页面上有多个表单，web2py 使用表单名称来确定提交了哪一个。如果页面包含单个表单，您可以设置`formname=None`和省略视图中的隐藏字段。

`form.accepts`将在内部`response.vars`查找与数据库表中的字段匹配的数据`db.person`。这些字段在 HTML 中以格式声明

```
<input name="field_name_goes_here" />
```

> 注意：HTML 表单使用`POST`协议（即表单变量不会在 URL 上传递）和`multipart/form-data`编码类型。上传字段需要后者才能工作。



#### `SQLFORM`和上传

“上传”类型的字段是特殊的。它们被呈现为 的 INPUT 字段`type="file"`。除非另有说明，否则上传的文件使用缓冲区流式传输，并使用自动分配的新安全名称存储在应用程序的“上传”文件夹下。然后将该文件的名称保存到“上传”类型的字段中。

例如，考虑以下模型：

```
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('image', 'upload'))
```

您可以使用上面显示的相同控制器操作“display_form”。

当您插入新记录时，表单允许您浏览文件。例如，选择 jpg 图像。该文件被上传并存储为：

```
applications/test/uploads/person.image.XXXXX.jpg
```

“XXXXXX”是 web2py 分配的文件的随机标识符。

> 请注意，默认情况下，上传文件的原始文件名是 b16 编码并用于构建文件的新名称。此名称由默认的“下载”操作检索，并用于将内容处置标头设置为原始文件名。

仅保留其扩展名。这是一项安全要求，因为文件名可能包含允许访问者执行目录遍历攻击或其他恶意操作的特殊字符。

新文件名也存储在`form.vars.image`.

使用 UPDATE 表单编辑记录时，最好显示一个指向现有上传文件的链接，而 web2py 提供了一种方法来做到这一点。

如果您通过参数将 URL 传递给`SQLFORM`构造`upload`函数，web2py 将使用该 URL 处的操作来下载文件。考虑以下操作：

```
def display_form():
   record = db.person(request.args(0))
   form = SQLFORM(db.person, record, deletable=True,
                  upload=URL('download'))
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)

def download():
    return response.download(request, db)
```

现在，在 URL 处插入一条新记录：

```
http://127.0.0.1:8000/test/default/display_form
```

上传图片，提交表单，然后通过访问编辑新创建的记录：

```
http://127.0.0.1:8000/test/default/display_form/3
```

（这里我们假设最新记录的 id=3）。表单将显示图像预览，如下所示：

![图片](http://web2py.com/books/default/image/29/en6300.png)



此表单在序列化时会生成以下 HTML：

```
<td><label id="person_image__label" for="person_image">Image: </label></td>
<td><div><input type="file" id="person_image" class="upload" name="image"
/>[<a href="/test/default/download/person.image.0246683463831.jpg">file</a>|
<input type="checkbox" name="image__delete" />delete]</div></td><td></td></tr>
<tr id="delete_record__row"><td><label id="delete_record__label" for="delete_record"
>Check to delete:</label></td><td><input type="checkbox" id="delete_record"
class="delete" name="delete_this_record" /></td>
```

其中包含一个允许下载上传文件的链接，以及一个用于从数据库记录中删除文件的复选框，因此将 NULL 存储在“图像”字段中。

为什么会暴露这个机制？为什么要写下载函数？因为您可能希望在下载功能中强制执行一些授权机制。有关示例，请参见[第 9 章。](http://web2py.com/books/default/chapter/29/09#Authorization-and-downloads)

通常上传的文件存储在“app/uploads”中，但您可以指定一个备用位置：

```
Field('image', 'upload', uploadfolder='...')
```

在大多数操作系统中，当同一文件夹中有许多文件时，访问文件系统会变得很慢。如果您计划上传超过 1000 个文件，您可以要求 web2py 将上传内容组织到子文件夹中：

```
Field('image', 'upload', uploadseparate=True)
```



#### 存储原始文件名

web2py 自动将原始文件名存储在新的 UUID 文件名中，并在下载文件时检索它。下载后，原始文件名存储在 HTTP 响应的 content-disposition 标头中。这一切都是透明地完成的，无需编程。

有时您可能希望将原始文件名存储在数据库字段中。在这种情况下，您需要修改模型并添加一个字段来存储它：

```
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('image_filename'),
    Field('image', 'upload'))
```

然后你需要修改控制器来处理它：

```
def display_form():
    record = db.person(request.args(0)) or redirect(URL('index'))
    url = URL('download')
    form = SQLFORM(db.person, record, deletable=True,
                   upload=url, fields=['name', 'image'])
    if request.vars.image != None:
        form.vars.image_filename = request.vars.image.filename
    if form.process().accepted:
        response.flash = 'form accepted'
    elif form.errors:
        response.flash = 'form has errors'
    return dict(form=form)
```

请注意，`SQLFORM`不显示“image_filename”字段。“display_form”操作将文件名移动`request.vars.image`到 中`form.vars.image_filename`，以便它被数据库处理`accepts`并存储在数据库中。下载功能在提供文件之前，会在数据库中检查原始文件名并在 content-disposition 标头中使用它。



#### `autodelete`

`SQLFORM`删除记录时，不会删除记录引用的物理上载文件。原因是 web2py 不知道同一个文件是否被其他表使用/链接或用于其他目的。如果您知道在删除相应记录时删除实际文件是安全的，则可以执行以下操作：

```
db.define_table('image',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('source', 'upload', autodelete=True))
```

该`autodelete`属性是`False`默认的。设置为`True`确保在删除记录时删除文件。



#### 引用记录的链接

现在考虑通过引用字段链接的两个表的情况。例如：

```
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()))
db.define_table('dog',
    Field('owner', 'reference person'),
    Field('name', requires=IS_NOT_EMPTY()))
db.dog.owner.requires = IS_IN_DB(db, 'person.id', '%(name)s')
```

一个人有狗，每条狗都属于一个主人，也就是一个人。狗主人必须参考有效`db.person.id`的 by `'%(name)s'`。

让我们使用这个应用程序的**appadmin**界面来添加一些人和他们的狗。

编辑现有人员时，**appadmin** UPDATE 表单会显示一个链接，该链接指向列出属于该人员的狗的页面。可以`linkto`使用`SQLFORM`. `linkto`必须指向从 接收查询字符串`SQLFORM`并列出相应记录的新操作的 URL。这是一个例子：

```
def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   link = URL('list_records', args='db')
   form = SQLFORM(db.person, record, deletable=True, linkto=link)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)
```

这是页面：



![图片](http://web2py.com/books/default/image/29/en6400.png)



有一个名为“dog.owner”的链接。可以通过 的`labels`参数更改此链接的名称`SQLFORM`，例如：

```
labels = {'dog.owner':"This person's dogs"}
```

如果您单击链接，您将被定向到：

```
/test/default/list_records/db/dog?query=db.dog.owner%3D%3D3
```

“list_records”是指定的动作，`request.args(0)`设置为引用表的名称，`request.vars.query`设置为SQL查询字符串。URL 中的查询字符串包含适当 url 编码的值“dog.owner==3”（解析 URL 时 web2py 会自动解码）。

您可以轻松实现一个非常通用的“list_records”操作，如下所示：

```
def list_records():
    import re
    REGEX = re.compile(r'^(\w+).(\w+).(\w+)==(\d+)$')
    match = REGEX.match(request.vars.query)
    if not match:
        redirect(URL('error'))
    table, field, id = match.group(2), match.group(3), match.group(4)
    records = db(db[table][field]==id).select()
    return dict(records=records)
```

使用关联的“default/list_records.html”视图：

```
{{extend 'layout.html'}}
{{=records}}
```

当 select 返回一组记录并在视图中序列化时，首先将其转换为 SQLTABLE 对象（与 Table 不同），然后序列化为 HTML 表，其中每个字段对应一个表列。



#### 预填充表单

始终可以使用以下语法预填充表单：

```
form.vars.name = 'fieldvalue'
```

必须在表单声明之后和接受表单之前插入上述语句，无论该字段（示例中的“名称”）是否在表单中显式可视化。



#### 添加额外的表单元素`SQLFORM`

有时您可能希望在表单创建后添加一个额外的元素。例如，您可能希望添加一个复选框，确认用户同意您网站的条款和条件：

```
form = SQLFORM(db.yourtable)
my_extra_element = TR(LABEL('I agree to the terms and conditions'),
                      INPUT(_name='agree', value=True, _type='checkbox'))
form[0].insert(-1, my_extra_element)
```

该变量`my_extra_element`应适应formstyle。在此示例中，`formstyle='table3cols'`已假定默认值。

提交后，`form.vars.agree`将包含复选框的状态，然后可以在`onvalidation`函数中使用，例如。



#### `SQLFORM`无数据库 IO

有时您希望使用从数据库表生成表单`SQLFORM`并相应地验证提交的表单，但您不希望数据库中有任何自动 INSERT/UPDATE/DELETE。例如，当需要根据其他输入字段的值计算其中一个字段时，就是这种情况。当您需要对无法通过标准验证器实现的插入数据执行额外验证时，也会出现这种情况。

这可以通过破坏来轻松完成：

```
form = SQLFORM(db.person)
if form.process().accepted:
    response.flash = 'record inserted'
      
```

进入：

```
form = SQLFORM(db.person)
if form.validate():
    ### deal with uploads explicitly
    form.vars.id = db.person.insert(**dict(form.vars))
    response.flash = 'record inserted'
      
```

更新/删除表单也可以通过以下方式完成：

```
form = SQLFORM(db.person, record)
if form.process().accepted:
    response.flash = 'record updated'
```

进入：

```
form = SQLFORM(db.person, record)
if form.validate():
    if form.deleted:
        db(db.person.id==record.id).delete()
    else:
        form.record.update_record(**dict(form.vars))
    response.flash = 'record updated'
```

对于包含“上传”类型字段（“fieldname”）的表，两者都`process(dbio=False)`处理`validate()`上传文件的存储，就像`process(dbio=True)`默认行为一样。

web2py 为上传文件分配的名称可以在以下位置找到：

```
form.vars.fieldname
```



### 其他类型的表格



#### `SQLFORM.factory`

在某些情况下，您想要生成表单*，就好像*您有一个数据库表但您不想要数据库表一样。您只是想利用`SQLFORM`生成漂亮的 CSS 友好表单的功能，并可能执行文件上传和重命名。

这可以通过`form_factory`. 这是一个示例，您可以在其中生成表单、执行验证、上传文件并将所有内容存储在`session`：

```
def form_from_factory():
    form = SQLFORM.factory(
        Field('your_name', requires=IS_NOT_EMPTY()),
        Field('your_image', 'upload'))
    if form.process().accepted:
        response.flash = 'form accepted'
        session.your_name = form.vars.your_name
        session.your_image = form.vars.your_image
    elif form.errors:
        response.flash = 'form has errors'
    return dict(form=form)
```

SQLFORM.factory() 构造函数中的 Field 对象在[第 6 章](http://web2py.com/books/default/chapter/29/06#Field-constructor)中有完整的说明。SQLFORM.factory() 的运行时构造技术是

```
fields = []
fields.append(Field(...))
form=SQLFORM.factory(*fields)
```

这是“default/form_from_factory.html”视图：

```
{{extend 'layout.html'}}
{{=form}}
```

您不能在字段名称中使用空格、在字段构造函数中显式设置标签（即`Field('field_name', ..., label='...')`）或传递`labels`to的字典`form_factory`，就像对`SQLFORM`. 默认情况下`SQLFORM.factory`，使用生成的 HTML“id”属性生成表单，就好像表单是从名为“no_table”的表生成的一样。要更改此虚拟表名称，请使用以下`table_name`参数：

```
form = SQLFORM.factory(..., table_name='other_dummy_name')
```

`table_name`如果您需要将两个工厂生成的表单放在同一个表中并希望避免 CSS 冲突，则需要更改。

##### 使用 SQLFORM.factory 上传文件



#### 一个表格用于多个表格

通常情况下，您有两个表（例如“客户”和“地址”，它们通过引用链接在一起，并且您希望创建一个允许插入有关一个客户及其默认地址的信息的单一表单。以下是如何：

模型：

```
db.define_table('client',
     Field('name'))
db.define_table('address',
    Field('client', 'reference client',
          writable=False, readable=False),
    Field('street'), Field('city'))
```

控制器：

```
def register():
    form = SQLFORM.factory(db.client, db.address)
    if form.process().accepted:
        id = db.client.insert(**db.client._filter_fields(form.vars))
        form.vars.client = id
        id = db.address.insert(**db.address._filter_fields(form.vars))
        response.flash = 'Thanks for filling the form'
    return dict(form=form)
```

请注意 SQLFORM.factory（它使用两个表中的公共字段创建一个表单并继承它们的验证器）。在表单上接受这两次插入，一个表中的一些数据和另一个表中的一些数据。

> 这仅在表没有共同的字段名称时才有效。



#### 确认表格

通常您需要一个带有确认选项的表格。如果选择被接受，则应接受该表格，即仅在提交时。该表单可能具有链接其他网页的附加选项。web2py 提供了一种简单的方法来做到这一点：

```
form = FORM.confirm('Are you sure?')
if form.accepted: do_what_needs_to_be_done()
```

请注意，确认表单不需要也不能调用`.accepts`，或者`.process`因为这是在内部完成的。您可以以字典的形式添加带有链接到确认表单的按钮`{'value':'link'}`：

```
form = FORM.confirm('Are you sure?', {'Back':URL('other_page')})
if form.accepted: do_what_needs_to_be_done()
```



#### 编辑字典的表格

想象一个将配置选项存储在字典中的系统，

```
config = dict(color='black', language='English')
```

你需要一个表单来允许访问者修改这个字典。这可以通过以下方式完成：

```
form = SQLFORM.dictform(config)
if form.process().accepted: config.update(form.vars)
```

该表单将为字典中的每个项目显示一个 INPUT 字段。它将使用字典键作为 INPUT 名称和标签以及当前值来推断类型（字符串、整数、双精度、日期、日期时间、布尔值）。

这很好用，但留给您使配置字典持久化的逻辑。例如，您可能希望将 存储`config`在会话中。

```
if not session.config:
    session.config = dict(color='black', language='English')
form = SQLFORM.dictform(session.config)
if form.process().accepted:
    session.config.update(form.vars)
```



### CRUD





创建/读取/更新/删除 (CRUD) API 是 SQLFORM 之上的实验性接口。它现在已被弃用，取而代之的是[SQLFORM.grid() 和 SQLFORM.smartgrid()](http://web2py.com/books/default/chapter/29/07/forms-and-validators#SQLFORM-grid-and-SQLFORM-smartgrid)，但在这里进行描述是因为一些应用程序已经使用它构建。

CRUD 创建了一个 SQLFORM，但它简化了编码，因为它将表单的创建、表单的处理、通知和重定向都集成在一个函数中。首先要注意的是，CRUD 与我们目前使用的其他 web2py API 不同，因为它尚未公开。它必须是进口的。它还必须链接到特定的数据库。例如：

```
from gluon.tools import Crud
crud = Crud(db)
```

上面定义的`crud`对象提供了以下 API：



.



- `crud.tables()`返回数据库中定义的表列表。
- `crud.create(db.tablename)`返回表 tablename 的创建表单。
- `crud.read(db.tablename, id)`返回表名和记录 ID 的只读形式。
- `crud.update(db.tablename, id)`返回表名和记录 ID 的更新表单。
- `crud.delete(db.tablename, id)`删除记录。
- `crud.select(db.tablename, query)`返回从表中选择的记录列表。
- `crud.search(db.tablename)`返回一个元组（表单，记录），其中表单是搜索表单，记录是基于提交的搜索表单的记录列表。
- `crud()`根据 . 返回上述其中一项`request.args()`。

例如，以下操作：

```
def data(): return dict(form=crud())
```

将公开以下 URL：

```
http://.../[app]/[controller]/data/tables
http://.../[app]/[controller]/data/create/[tablename]
http://.../[app]/[controller]/data/read/[tablename]/[id]
http://.../[app]/[controller]/data/update/[tablename]/[id]
http://.../[app]/[controller]/data/delete/[tablename]/[id]
http://.../[app]/[controller]/data/select/[tablename]
http://.../[app]/[controller]/data/search/[tablename]
```

但是，以下操作：

```
def create_tablename():
    return dict(form=crud.create(db.tablename))
```

只会暴露 create 方法

```
http://.../[app]/[controller]/create_tablename
```

同时执行以下操作：

```
def update_tablename():
    return dict(form=crud.update(db.tablename, request.args(0)))
```

只会暴露更新方法

```
http://.../[app]/[controller]/update_tablename/[id]
```

等等。

可以通过两种方式自定义 CRUD 的行为：通过设置`crud`对象的某些属性或通过向其每个方法传递额外的参数。



#### 设置

以下是当前 CRUD 属性、它们的默认值和含义的完整列表：

要对所有 crud 表单强制执行身份验证：

```
crud.settings.auth = auth
```

这将在[第 9 章](http://web2py.com/books/default/chapter/29/09#Authorization-and-CRUD)中解释。

指定定义`data`返回`crud`对象的函数的控制器

```
crud.settings.controller = 'default'
```

要在成功“创建”记录后指定要重定向到的 URL：

```
crud.settings.update_next = URL('index')
```

要指定在成功“更新”记录后重定向到的 URL：

```
crud.settings.update_next = URL('index')
```

要指定在成功“删除”记录后重定向到的 URL：

```
crud.settings.delete_next = URL('index')
```

要指定用于链接上传文件的 URL：

```
crud.settings.download_url = URL('download')
```

要在表单的标准验证程序之后指定要执行的额外功能`crud.create`：

```
crud.settings.create_onvalidation = StorageList()
```

`StorageList`与对象相同`Storage`，它们都在文件“gluon/storage.py”中定义，但默认`[]`为与`None`. 它允许以下语法：

```
crud.settings.create_onvalidation.mytablename.append(lambda form: ...)
```

要在表单的标准验证程序之后指定要执行的额外功能`crud.update`：

```
crud.settings.update_onvalidation = StorageList()
```

`crud.create`指定完成表格后要执行的额外功能：

```
crud.settings.create_onaccept = StorageList()
```

`crud.update`指定完成表格后要执行的额外功能：

```
crud.settings.update_onaccept = StorageList()
```

`crud.update`指定如果记录被删除完成后要执行的额外功能：

```
crud.settings.update_ondelete = StorageList()
```

指定完成后要执行的额外功能`crud.delete`：

```
crud.settings.delete_onaccept = StorageList()
```

要确定“更新”表单是否应该有“删除”按钮：

```
crud.settings.update_deletable = True
```

要确定“更新”表单是否应显示已编辑记录的 id：

```
crud.settings.showid = False
```

要确定表单是否应保留先前插入的值或在成功提交后重置为默认值：

```
crud.settings.keepvalues = False
```

Crud 始终检测正在编辑的记录是否在表单显示和提交之间的时间内被第三方修改。这种行为相当于它设置在：

```
crud.settings.detect_record_change = True
```

并且可以通过将变量设置为 来更改/禁用它`False`。

您可以通过以下方式更改表单样式

```
crud.settings.formstyle = 'table3cols' or 'table2cols' or 'divs' or 'ul'
```

您可以在所有 crud 形式中设置分隔符：

```
crud.settings.label_separator = ':'
```



#### 验证码

`auth.settings`您可以使用解释的相同约定（参见[第 9 章](http://web2py.com/books/default/chapter/29/09#captcha_settings)）将验证码添加到表单中，其中：

```
crud.settings.create_captcha = None
crud.settings.update_captcha = None
crud.settings.captcha = None
```



#### Messages

以下是可自定义消息的列表：

```
crud.messages.submit_button = 'Submit'
```

为创建和更新表单设置“提交”按钮的文本。

```
crud.messages.delete_label = 'Check to delete'
```

在“更新”表单中设置“删除”复选框的标签。

```
crud.messages.record_created = 'Record Created'
```

设置成功创建记录时的闪烁消息。

```
crud.messages.record_updated = 'Record Updated'
```

设置成功记录更新时的闪烁消息。

```
crud.messages.record_deleted = 'Record Deleted'
```

设置成功删除记录时的闪烁消息。

```
crud.messages.update_log = 'Record %(id)s updated'
```

设置成功记录更新的日志消息。

```
crud.messages.create_log = 'Record %(id)s created'
```

设置成功创建记录时的日志消息。

```
crud.messages.read_log = 'Record %(id)s read'
```

设置成功记录读取访问的日志消息。

```
crud.messages.delete_log = 'Record %(id)s deleted'
```

设置成功删除记录的日志消息。

> 请注意，它属于类似于`crud.messages`的类，但它会自动转换其值，而不需要运算符。`gluon.storage.Message``gluon.storage.Storage``T`

当且仅当 CRUD 连接到 Auth（如[第 9 章](http://web2py.com/books/default/chapter/29/09#Authorization-and-CRUD)中讨论的）并且也附加了 CRUD 记录器时，才会使用日志消息：

```
crud.settings.logger = crud.settings.auth = auth
```

事件记录在 Auth 表中`auth_event`。



#### 方法

CRUD 方法的行为也可以在每次调用的基础上进行定制。以下是他们的签名：

```
crud.tables()
crud.create(table, next, onvalidation, onaccept, log, message, formname, **attributes)
crud.read(table, record)
crud.update(table, record, next, onvalidation, onaccept, ondelete, log, message, deletable)
crud.delete(table, record_id, next, message)
crud.select(table, query, fields, orderby, limitby, headers, **attr)
crud.search(table, query, queries, query_labels, fields, field_labels, zero, showall, chkall)
```

- `table`是 DAL 表或方法应该作用的表名。
- `record`并且`record_id`是方法应该作用的记录的id。
- `next`是成功后重定向到的 URL。如果 URL 包含子字符串“[id]”，它将被当前创建/更新的记录的 id 替换（用于`URL(..., url_encode=False)`防止括号被转义）。
- `onvalidation`具有与 FORM 和 SQLFORM 相同的功能（参见[onvalidation](http://web2py.com/books/default/chapter/29/07/forms-and-validators#onvalidation)部分）
- `onaccept`是在表单提交被接受并采取行动之后但在重定向之前调用的函数。这将使用作为参数传递的表单来调用。
- `log`是日志消息。CRUD 中的日志消息可以查看`form.vars`字典中的变量，例如“%(id)s”（实际记录的消息是`log % form.vars`）。
- `message`是表单接受时的闪现消息。
- `formname`是用于生成的 SQLFORM 的名称，当您希望在同一页面上有多个表单时可能需要此名称（有关详细信息，请参阅每页[多个表单](http://web2py.com/books/default/chapter/29/07/forms-and-validators#Multiple-forms-per-page)部分）。
- `**attributes`要传递给构造函数的附加`crud.create`和关键字参数。`crud.update``SQLFORM`
- `ondelete``onaccept`代替通过“更新”表单删除记录时调用。
- `deletable`确定“更新”表单是否应具有删除选项。
- `query`是用于选择记录的查询。
- `fields`是要选择的字段列表。
- `orderby`确定应选择记录的顺序（参见[第 6 章](http://web2py.com/books/default/chapter/29/06#orderby)）。
- `limitby`确定应显示的选定记录的范围（参见[第 6 章](http://web2py.com/books/default/chapter/29/06#limitby)）。
- `headers`是一个字典，将字段名称映射到要传递给`SQLTABLE`构造函数的标头名称（参见[第 6 章](http://web2py.com/books/default/chapter/29/06#sqltable)）。
- `queries`一个列表，例如`['equals', 'not equal', 'contains']`包含搜索表单中允许的方法。
- `query_labels`像`query_labels=dict(equals='Equals')`给搜索方法起名字的字典。
- `fields`要在搜索小部件中列出的字段列表。
- `field_labels`将字段名称映射到标签的字典。
- `zero`默认为“选择一个”用作搜索小部件中下拉菜单的默认选项。
- `showall`如果您希望根据第一次调用中的查询返回行（在 1.98.2 之后添加），请将其设置为 True。
- `chkall`将其设置为 True 以打开搜索表单中的所有复选框（在 1.98.2 之后添加）。
- `**attr``crud.select`要传递给构造函数的附加关键字参数`SQLTABLE`（参见[第 6 章](http://web2py.com/books/default/chapter/29/06#sqltable)）。

以下是单个控制器功能中的使用示例：

```
## assuming db.define_table('person', Field('name'))
def people():
    form = crud.create(db.person, next=URL('index'),
                       message=T("record created"))
    persons = crud.select(db.person, fields=['name'],
                          headers={'person.name': 'Name'})
    return dict(form=form, persons=persons)
```

这是另一个非常通用的控制器函数，可让您搜索、创建和编辑任何表中的任何记录，其中表名在 request.args(0) 中传递：

```
def manage():
    table = db[request.args(0)]
    form = crud.update(table, request.args(1))
    table.id.represent = lambda id, row: \
       A('edit:', id, _href=URL(args=(request.args(0), id)))
    search, rows = crud.search(table)
    return dict(form=form, search=search, rows=rows)
```

请注意`table.id.represent=...`告诉 web2py 更改 id 字段的表示并显示指向页面本身的链接并将 id 作为 request.args(1) 传递的行，这会将创建页面转换为更新页面。



#### 记录版本控制

SQLFORM 和 CRUD 都为版本数据库记录提供了一个实用程序：

如果您有一个需要完整修订历史记录的表（db.mytable），您可以这样做：

```
form = SQLFORM(db.mytable, myrecord).process(onsuccess=auth.archive)
```



```
form = crud.update(db.mytable, myrecord, onaccept=auth.archive)
```

`auth.archive`定义了一个名为**db.mytable_archive**的新表（该名称源自它所引用的表的名称），并且在更新时，它将记录的副本（与更新前一样）存储在创建的存档表中，包括对当前记录的引用。

因为记录实际上是更新的（只有它以前的状态被归档），所以引用永远不会被破坏。

这一切都是在引擎盖下完成的。如果您希望访问存档表，您应该在模型中定义它：

```
db.define_table('mytable_archive',
   Field('current_record', 'reference mytable'),
   db.mytable)
   
```

请注意该表扩展`db.mytable`（包括其所有字段），并添加对`current_record`.

`auth.archive`除非您的原始表具有时间戳字段，否则不会为存储的记录添加时间戳，例如：

```
db.define_table('mytable',
    Field('created_on', 'datetime',
          default=request.now, update=request.now, writable=False),
    Field('created_by', 'reference auth_user',
          default=auth.user_id, update=auth.user_id, writable=False),
```

这些字段没有什么特别之处，你可以给它们起任何你喜欢的名字。它们在记录存档之前填写，并与记录的每个副本一起存档。存档表名称和/或参考字段名称可以这样更改：

```
db.define_table('myhistory',
    Field('parent_record', 'reference mytable'),
    db.mytable)
## ...
form = SQLFORM(db.mytable, myrecord)
form.process(onsuccess = lambda form:auth.archive(form,
             archive_table=db.myhistory,
             current_record='parent_record'))
```



### 自定义表格

如果使用 SQLFORM、SQLFORM.factory 或 CRUD 创建表单，则可以通过多种方式将其嵌入到视图中，从而实现多种程度的定制。例如考虑以下模型：

```
db.define_table('image',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('source', 'upload'))
```

并上传动作

```
def upload_image():
    return dict(form=SQLFORM(db.image).process())
```

将表单嵌入视图的最简单方法`upload_image`是

```
{{=form}}
```

这会产生标准的表格布局。如果您希望使用不同的布局，可以将表单分解为组件

```
{{=form.custom.begin}}
Name: <div>{{=form.custom.widget.name}}</div>
File: <div>{{=form.custom.widget.source}}</div>
{{=form.custom.submit}}
{{=form.custom.end}}
```

where`form.custom.widget[fieldname]`被序列化为该字段的正确小部件。如果表单已提交并且包含错误，它们会像往常一样附加在小部件下方。

上面的示例表格如下图所示。



![图片](http://web2py.com/books/default/image/29/en6500.png)



不使用自定义表单也可以获得类似的结果：

```
SQLFORM ( ... ,  formstyle = 'table2cols' )
```

或者对于具有以下参数的 CRUD 表单：

```
粗鲁。设置。formstyle = 'table2cols'
```

有关其他可能的值，请参阅[SQLFORM](http://web2py.com/books/default/chapter/29/07/forms-and-validators#formstyle)`formstyle`参数的描述。

如果您不想使用 web2py 序列化的小部件，您可以将它们替换为 HTML。有一些变量对此有用：

- `form.custom.label[fieldname]`包含字段的标签。
- `form.custom.comment[fieldname]`包含该字段的注释。
- `form.custom.dspval[fieldname]`表单类型和字段类型相关的字段显示表示。
- `form.custom.inpval[fieldname]`要在字段代码中使用的表单类型和字段类型相关值。

如果您的表格有`deletable=True`，您还应该插入

```
{{ =形式. 自定义. 删除}}
```

显示删除复选框。

遵循下述约定很重要。



#### CSS 约定

SQLFORM、SQLFORM.factory 和 CRUD 生成的表单中的标签遵循严格的 CSS 命名约定，可用于进一步自定义表单。

给定一个表“mytable”和一个类型为“string”的字段“myfield”，它默认由

```
SQLFORM.widgets.string.widget
```

看起来像这样：

```
<input type="text" name="myfield" id="mytable_myfield"
       class="string" />
```

请注意：

- INPUT 标记的类别与字段的类型相同。这对于“web2py_ajax.html”中的 jQuery 代码的工作非常重要。它确保您只能在“整数”和“双”字段中包含数字，并且“时间”、“日期”和“日期时间”字段显示弹出日历/日期选择器。
- id 是类名加上字段名，用一个下划线连接。这允许您通过例如唯一地引用该字段，`jQuery('#mytable_myfield')`并操作该字段的样式表或绑定与该字段事件（焦点、模糊、按键等）相关联的操作。
- 如您所料，该名称是字段名称。



#### 隐藏错误

有时，您可能希望禁用自动错误放置并在默认位置以外的其他位置显示表单错误消息。这很容易做到。

- 在 FORM 或 SQLFORM 的情况下，传递`hideerror=True`给`accepts`方法。
- 在 CRUD 的情况下，设置`crud.settings.hideerror=True`

您可能还想修改视图以显示错误（因为它们不再自动显示）。

这是一个错误显示在表单上方而不是在表单中的示例。

```
{{if form.errors:}}
  Your submitted form contains the following errors:
  <ul>
  {{for fieldname in form.errors:}}
    <li>{{=fieldname}} error: {{=form.errors[fieldname]}}</li>
  {{pass}}
  </ul>
  {{form.errors.clear()}}
{{pass}}
{{=form}}
```

错误将如下图所示。



![图片](http://web2py.com/books/default/image/29/en6600.png)



此机制也适用于自定义表单。



### 验证器

验证器是用于验证输入字段（包括从数据库表生成的表单）的类。使用从 SQLFORM 派生的高级表单，验证器可以创建小部件，例如下拉菜单和从其他表中查找。

以下是使用带有`FORM`字段的验证器的示例：

```
INPUT(_name='a', requires=IS_INT_IN_RANGE(0, 10))
```

下面是一个如何为表字段要求验证器的示例：

```
db.define_table('person', Field('name'))
db.person.name.requires = IS_NOT_EMPTY()
```

`requires`验证器始终使用字段的属性进行分配。一个字段可以有一个验证器或多个验证器。多个验证器成为列表的一部分：

```
db.person.name.requires = [IS_NOT_EMPTY(),
                           IS_NOT_IN_DB(db, 'person.name')]
```

通常验证器由函数`accepts`和包含表单`process`的或其他 HTML 帮助器对象自动调用。`FORM`它们按列出的顺序调用。

也可以为一个字段显式调用验证器：

```
db.person.name.validate(value)
```

它返回一个元组`(value, error)`，`error`如果`None`值有效。

内置验证器具有带有可选参数的构造函数：

```
IS_NOT_EMPTY(error_message='cannot be empty')
```

`error_message`允许您覆盖任何验证器的默认错误消息。

以下是数据库表上的验证器示例：

```
db.person.name.requires = IS_NOT_EMPTY(error_message='fill this!')
```

我们使用翻译运算符`T`来实现国际化。请注意，默认错误消息不会被翻译。

请注意，唯一可以与`list:`类型字段一起使用的验证器是：

- `IS_IN_DB(..., multiple=True)`
- `IS_IN_SET(..., multiple=True)`
- `IS_NOT_EMPTY()`
- `IS_LIST_OF_EMAILS()`
- `IS_LIST_OF(...)`

后者可用于将任何验证器应用于列表中的各个项目。`multiple=(1, 1000)`需要从 1 到 1000 个项目中进行选择。这强制选择至少一个选项。



#### 文本格式验证器

##### `IS_ALPHANUMERIC`

此验证器检查字段值是否仅包含 az、AZ 或 0-9 范围内的字符。

```
requires = IS_ALPHANUMERIC(error_message='must be alphanumeric!')
```

##### `IS_LOWER`

此验证器从不返回错误。它只是将值转换为小写。

```
requires = IS_LOWER()
```

##### `IS_UPPER`

此验证器从不返回错误。它将值转换为大写。

```
requires = IS_UPPER()
```

##### `IS_EMAIL`

它检查字段值是否看起来像电子邮件地址。它不会尝试发送电子邮件进行确认。

```
requires = IS_EMAIL(error_message='invalid email!')
```

##### `IS_MATCH`

此验证器将值与正则表达式匹配，如果不匹配则返回错误。以下是验证美国邮政编码的示例：

```
requires = IS_MATCH('^\d{5}(-\d{4})?$',
         error_message='not a zip code')
```

以下是验证 IPv4 地址的示例（注意：IS_IPV4 验证器更适合此目的）：

```
requires = IS_MATCH('^\d{1,3}(.\d{1,3}){3}$',
         error_message='not an IP address')
```

以下是验证美国电话号码的用法示例：

```
requires = IS_MATCH('^1?((-)\d{3}-?|\(\d{3}\))\d{3}-?\d{4}$',
         error_message='not a phone number')
```

有关 Python 正则表达式的更多信息，请参阅 Python 官方文档。

`IS_MATCH`接受一个可选参数`strict`，默认为`False`. 当设置为`True`它只匹配整个字符串（从头到尾）：

```
>>> IS_MATCH('ab', strict=False)('abc')
('abc', None)
>>> IS_MATCH('ab', strict=True)('abc')
('abc', 'Invalid expression')
```

`IS_MATCH`采用其他可选参数`search`，默认为`False`. 当设置为 时`True`，它使用正则表达式方法`search`而不是方法`match`来验证字符串。

`IS_MATCH('...', extract=True)`过滤并仅提取第一个匹配的子字符串而不是原始值。

##### `IS_LENGTH`

检查字段值的长度是否适合给定边界。适用于文本和文件输入。

它的论点是：

- maxsize：允许的最大长度/大小（默认值 = 255）
- minsize：允许的最小长度/大小

示例：检查文本字符串是否短于 33 个字符：

```
INPUT(_type='text', _name='name', requires=IS_LENGTH(32))
```

检查密码字符串是否超过 5 个字符：

```
INPUT(_type='password', _name='name', requires=IS_LENGTH(minsize=6))
```

检查上传的文件大小是否在 1KB 和 1MB 之间：

```
INPUT(_type='file', _name='name', requires=IS_LENGTH(1048576, 1024))
```

对于除文件之外的所有字段类型，它会检查值的长度。对于文件，该值为 a `cgi.FieldStorage`，因此它验证文件中数据的长度，这是人们可能直观预期的行为。

##### `IS_URL`

如果以下任何一项为真，则拒绝 URL 字符串：

- 字符串为空或无
- 该字符串使用了 URL 中不允许的字符
- 该字符串破坏了任何 HTTP 语法规则
- 指定的 URL 方案（如果指定）不是“http”或“https”
- 顶级域（如果指定了主机名）不存在

（这些规则基于 RFC 2616 [ [RFC2616](http://web2py.com/books/default/reference/29/RFC2616) ]）

此函数仅检查 URL 的语法。例如，它不检查 URL 是否指向真实文档，或者它是否具有语义意义。如果是缩写 URL（例如“google.ca”），此函数会自动在 URL 前添加“http://”。

如果使用参数 mode='generic'，则此函数的行为会发生变化。如果以下任何一项为真，它就会拒绝 URL 字符串：

- 字符串为空或无
- 该字符串使用了 URL 中不允许的字符
- 指定的 URL 方案（如果指定）无效

（这些规则基于 RFC 2396 [ [RFC2396](http://web2py.com/books/default/reference/29/RFC2396) ]）

允许的方案列表可使用 allowed_schemes 参数进行自定义。如果您从列表中排除 None，那么缩写 URL（缺少诸如“http”之类的方案）将被拒绝。

默认的前置方案可使用 prepend_scheme 参数进行自定义。如果您将 prepend_scheme 设置为 None，那么 prepend 将被禁用。仍然会接受需要预先解析的 URL，但不会修改返回值。

IS_URL 与 RFC 3490 [ [RFC3490](http://web2py.com/books/default/reference/29/RFC3490) ]中指定的国际化域名 (IDN) 标准兼容。因此，URL 可以是常规字符串或 unicode 字符串。如果 URL 的域组件（例如 google.ca）包含非 US-ASCII 字母，那么域将被转换为 Punycode（在 RFC 3492 [ [RFC3492](http://web2py.com/books/default/reference/29/RFC3492) ]中定义）。IS_URL 有点超出标准，并且允许非 US-ASCII 字符出现在 URL 的路径和查询组件中。这些非 US-ASCII 字符将被编码。例如，空格将被编码为'%20'。十六进制代码 0x4e86 的 unicode 字符将变为“%4e%86”。

例子：

```
requires = IS_URL())
requires = IS_URL(mode='generic')
requires = IS_URL(allowed_schemes=['https'])
requires = IS_URL(prepend_scheme='https')
requires = IS_URL(mode='generic',
                  allowed_schemes=['ftps', 'https'],
                  prepend_scheme='https')
```

##### `IS_SLUG`

```
requires = IS_SLUG(maxlen=80, check=False, error_message='must be slug')
```

如果`check`设置为`True`它检查验证的值是否是 slug（只允许字母数字字符和不重复的破折号）。

如果`check`设置为`False`（默认），它会将输入值转换为 slug。

##### `IS_JSON`

```
requires = IS_JSON(error_message='Invalid json', native_json=False)
```

此验证器检查字段值是否为 JSON 格式。

如果`native_json`设置为`False`（默认），它将输入值转换为序列化值，否则输入值保持不变。



#### 日期和时间验证器

##### `IS_TIME`

此验证器检查字段值是否包含指定格式的有效时间。

```
requires = IS_TIME(error_message='must be HH:MM:SS!')
```

##### `IS_DATE`

此验证器检查字段值是否包含指定格式的有效日期。使用翻译运算符指定格式是一种很好的做法，以便在不同的语言环境中支持不同的格式。

```
requires = IS_DATE(format=T('%Y-%m-%d'),
                   error_message='must be YYYY-MM-DD!')
```

有关 % 指令的完整描述，请查看 IS_DATETIME 验证器。

##### `IS_DATETIME`

此验证器检查字段值是否包含指定格式的有效日期时间。使用翻译运算符指定格式是一种很好的做法，以便在不同的语言环境中支持不同的格式。

```
requires = IS_DATETIME(format=T('%Y-%m-%d %H:%M:%S'),
                       error_message='must be YYYY-MM-DD HH:MM:SS!')
```

以下符号可用于格式字符串（这显示了符号、它们的含义和示例字符串）：

```
%Y  year with century (e.g. '1963')
%y  year without century (e.g. '63')
%d  day of the month (e.g. '28')
%m  month (e.g '08')
%b  abbreviated month name (e.g.'Aug')
%B  full month name (e.g. 'August')
%H  hour (24-hour clock, e.g. '14')
%I  hour (12-hour clock, e.g. '02')
%p  either 'AM' or 'PM'
%M  minute (e.g. '30')
%S  second (e.g. '59')
```

##### `IS_DATE_IN_RANGE`

与之前的验证器非常相似，但允许指定范围：

```
requires = IS_DATE_IN_RANGE(format=T('%Y-%m-%d'),
                   minimum=datetime.date(2008, 1, 1),
                   maximum=datetime.date(2009, 12, 31),
                   error_message='must be YYYY-MM-DD!')
```

有关 % 指令的完整描述，请查看 IS_DATETIME 验证器。

##### `IS_DATETIME_IN_RANGE`

与之前的验证器非常相似，但允许指定范围：

```
requires = IS_DATETIME_IN_RANGE(format=T('%Y-%m-%d %H:%M:%S'),
                       minimum=datetime.datetime(2008, 1, 1, 10, 30),
                       maximum=datetime.datetime(2009, 12, 31, 11, 45),
                       error_message='must be YYYY-MM-DD HH:MM::SS!')
```

有关 % 指令的完整描述，请查看 IS_DATETIME 验证器。



#### 范围、集合和相等验证器

##### `IS_EQUAL_TO`

检查验证值是否等于给定值（可以是变量）：

```
requires = IS_EQUAL_TO(request.vars.password,
                       error_message='passwords do not match')
```

##### `IS_NOT_EMPTY`

此验证器检查字段值的内容是否既不是 None 也不是空字符串或空列表。在 之后检查字符串值`.strip()`。

```
requires = IS_NOT_EMPTY(error_message='cannot be empty!')
```

您可以提供一个正则表达式来匹配空字符串。

```
requires = IS_NOT_EMPTY(error_message='Enter a value', empty_regex='NULL(?i)')
```

##### `IS_NULL_OR`

`IS_EMPTY_OR`已弃用，下面描述的别名。

##### `IS_EMPTY_OR`

有时您需要在字段上允许空值以及其他要求。例如，字段可以是日期，但也可以为空。验证器`IS_EMPTY_OR`允许这样做：

```
requires = IS_EMPTY_OR(IS_DATE())
```

空值是 None 或空字符串或空列表。在 之后检查字符串值`.strip()`。

您可以为空字符串与`empty_regex`参数的匹配提供正则表达式（例如 IS_NOT_EMPTY 验证器）。

您还可以指定一个用于空案例的值。

```
requires = IS_EMPTY_OR(IS_ALPHANUMERIC(), null='anonymous')
```

##### `IS_EXPR`

这个验证器让您可以通过一个可调用的方法来表达一般条件，该可调用接受一个值来验证并返回错误消息或`None`接受输入值。

```
requires = IS_EXPR(lambda v: T('not divisible by 3') if int(v) % 3 else None)
```

> 请注意，如果您不另行安排，返回的消息将不会被翻译。

为了向后兼容，条件可以表示为一个字符串，该字符串包含根据变量值的逻辑表达式。如果表达式的计算结果为 ，它将验证字段值`True`。

```
requires = IS_EXPR('int(value) % 3 == 0',
                   error_message='not divisible by 3')
```

应首先检查该值是否为整数，以免发生异常。

```
requires = [IS_INT_IN_RANGE(0, None),
            IS_EXPR(lambda v: T('not divisible by 3') if v % 3 else None)]
```

##### `IS_DECIMAL_IN_RANGE`

```
INPUT(_type='text', _name='name', requires=IS_DECIMAL_IN_RANGE(0, 10, dot="."))
```

它将输入转换为 Python 十进制，如果十进制不在指定的包含范围内，则生成错误。比较是用 Python Decimal 算术进行的。

最小和最大限制可以是无，分别表示没有下限或上限。

该`dot`参数是可选的，允许您将用于分隔小数的符号国际化。

##### `IS_FLOAT_IN_RANGE`

检查字段值是否为确定范围内的浮点数，`0 <= value <= 100`在以下示例中：

```
requires = IS_FLOAT_IN_RANGE(0, 100, dot=".",
                             error_message='negative or too large!')
```

该`dot`参数是可选的，允许您将用于分隔小数的符号国际化。

##### `IS_INT_IN_RANGE`

检查字段值是否为确定范围内的整数，`0 <= value < 100`在以下示例中：

```
requires = IS_INT_IN_RANGE(0, 100,
                           error_message='negative or too large!')
```

##### `IS_IN_SET`

在 SQLFORM（和网格）中，此验证器将自动将表单字段设置为选项字段（即，带有下拉菜单）。

`IS_IN_SET`检查字段值是否在集合中：

```
requires = IS_IN_SET(['a', 'b', 'c'], zero=T('choose one'),
                     error_message='must be a or b or c')
```

零参数是可选的，它确定默认选择的选项的文本，`IS_IN_SET`验证器本身不接受该选项。如果您不想要“选择一个”选项，请设置`zero=None`.

只要 IS_IN_SET 在列表中，集合的元素可以与数字验证器组合。这样做会强制最后一个验证器转换为数字类型。因此，IS_IN_SET 可以后跟`IS_INT_IN_RANGE`（将值转换为 int）或`IS_FLOAT_IN_RANGE`（将值转换为浮点数）。例如：

```
requires = [ IS_IN_SET([2, 3, 5, 7], error_message='must be prime and less than 10'),
             IS_INT_IN_RANGE(0, None) ]]
```



###### 复选框验证

要强制填写表单复选框（例如接受条款和条件），请使用：

```
requires=IS_IN_SET(['on'])
```

###### 带有 IS_IN_SET 的字典和元组

您还可以使用字典或元组列表来使下拉列表更具描述性：

```
Dictionary example:
requires = IS_IN_SET({'A':'Apple', 'B':'Banana', 'C':'Cherry'}, zero=None)

List of tuples example:
requires = IS_IN_SET([('A', 'Apple'), ('B', 'Banana'), ('C', 'Cherry')])
```

###### 排序选项

要将选项按其标签按字母顺序排列到下拉列表中，请使用`sort`带有 IS_IN_SET 的参数。

```
IS_IN_SET([('H', 'Hulk'), ('S', 'Superman'), ('B', 'Batman')], sort=True)
```

##### `IS_IN_SET`和标记

验证器`IS_IN_SET`有一个可选属性`multiple=False`。如果设置为 True，则可以在一个字段中存储多个值。该字段应该是类型`list:integer`或在[第 6 章](http://web2py.com/books/default/chapter/29/06#list-type-and-contains)`list:string`中讨论过。那里讨论了一个明确的标记示例。我们强烈建议使用 jQuery 多选插件来呈现多个字段。

> 请注意，当`multiple=True`,`IS_IN_SET`将接受零个或多个值，即当没有选择任何内容时它将接受该字段。`multiple`也可以是形式的元组，`(a, b)`其中`a`和`b`是可以分别选择的最小和（不包括）最大项目数。



#### 复杂性和安全性验证器

##### `IS_STRONG`

对字段（通常是密码字段）强制执行复杂性要求。

例子：

```
requires = IS_STRONG(min=10, special=2, upper=2)
```

在哪里：

- `min`是值的最小长度
- `special`是所需特殊字符的最小数量，默认情况下特殊字符是以下任何一种`~!!@#$%^&*()_+-=?<>,.:;{}[]|`（您可以使用自定义这些`specials = '...'`）
- `upper`是大写字符的最小数量

其他接受的论点是：

- `invalid`对于禁用字符列表，默认情况下`invalid=' "'`
- `max`对于值的最大长度
- `lower`对于小写字符的最小数量
- `number`最小数字字符数

显然，您可以提供`error_message`与任何其他验证器相同的信息，尽管 IS_STRONG 足够聪明，可以提供清晰的消息来描述验证失败。

您可以使用的一个特殊参数是`entropy`，这是要接受的值的复杂性的最小值（一个数字），请尝试以下方法：

```
>>>  IS_STRONG ( entropy = 100.0 )( 'hello' ) 
( 'hello' ,  Entropy  ( 24.53 ) 小于 要求( 100.0  ) ) 
```

> 请注意，如果`entropy`未给出参数，则 IS_STRONG 隐式设置以下默认值：`min = 8, upper = 1, lower = 1, number = 1, special = 1`否则将全部设置为`None`.

##### `CRYPT`

这也是一个过滤器。它对输入执行安全散列，并用于防止密码以明文形式传递给数据库。

```
requires = CRYPT()
```

默认情况下，CRYPT 使用 pbkdf2 算法与 SHA512 的 1000 次迭代来生成 20 字节长的散列。旧版本的 web2py 使用 md5 或 HMAC+SHA512，具体取决于是否指定了密钥。

如果指定了密钥，CRYPT 将使用 HMAC 算法。密钥可能包含一个前缀，用于确定与 HMAC 一起使用的算法，例如 SHA512：

```
requires = CRYPT(key='sha512:thisisthekey')
```

这是推荐的语法。键必须是与使用的数据库关联的唯一字符串。密钥永远无法更改。如果您丢失了密钥，则之前的散列值将变得无用。

默认情况下，CRYPT 使用随机盐，因此每个结果都是不同的。要使用常量盐值，请指定其值：

```
requires = CRYPT(salt='mysaltvalue')
```

或者，不使用盐：

```
requires = CRYPT(salt=False)
```

CRYPT 验证器对其输入进行散列处理，这使它有些特别。如果您需要在哈希之前验证密码字段，您可以在验证器列表中使用 CRYPT，但必须确保它是列表的最后一个，以便最后调用它。例如：

```
requires = [IS_STRONG(), CRYPT(key='sha512:thisisthekey')]
```

`CRYPT`还接受一个`min_length`参数，默认为零。

生成的哈希采用形式`alg$salt$hash`，其中`alg`是使用的哈希算法，`salt`是盐字符串（可以为空），`hash`是算法的输出。因此，散列是自识别的，例如，允许在不使先前的散列无效的情况下更改算法。但是，密钥必须保持不变。



#### 特殊类型验证器

##### `IS_LIST_OF`

此验证器可帮助您确保列表类型值的长度限制，为此使用其`minimum`、`maximum`和`error_message`参数，例如：

```
requires = IS_LIST_OF(minimum=2)
```

列表值可能来自包含多个同名字段的表单或多个选择框。请注意，此验证器会自动将非列表值转换为单值列表：

```
>>> IS_LIST_OF()('hello')
(['hello'], None)
```

如果 IS_LIST_OF 的第一个参数是另一个验证器，那么它将另一个验证器应用于列表的每个元素。一个典型的用法是验证`list:`类型字段，例如：

```
Field('emails', 'list:string', requires=IS_LIST_OF(IS_EMAIL()), ...)
```

##### `IS_LIST_OF_EMAILS`

该验证器专门设计用于以下领域：

```
Field('emails', 'list:string',
      widget=SQLFORM.widgets.text.widget,
      requires=IS_LIST_OF_EMAILS(),
      filter_in=lambda l: \
          IS_LIST_OF_EMAILS.split_emails.findall(l[0]) if l else l,
      represent=lambda v, r: \
          XML(', '.join([A(x, _href='mailto:'+x).xml() for x in (v or [])]))
     )
```

请注意，由于`widget`自定义，此字段将由 SQLFORMs 中的文本区域呈现（请参阅下一个[小部件](http://web2py.com/books/default/chapter/29/07/forms-and-validators#Widgets)部分）。这使您可以在单个输入字段中插入和编辑多封电子邮件（非常像普通邮件客户端程序所做的那样），用 、 和空格（空格、换行符和制表符）分隔每个电子邮件`,`地址`;`。作为一个结果，现在我们需要一个能够对单个值输入进行操作的验证器，以及一种将验证值拆分为一个列表以供 DAL 下一步处理的方法，这些就是`requires`和`filter_in`参数所代表的内容。作为替代方法`filter_in`，您可以将以下函数传递给`onvalidation`form 、 或 method 的参数`accepts`（`process`请`validate`参阅[onvalidation](http://web2py.com/books/default/chapter/29/07/forms-and-validators#onvalidation)部分）：

```
def emails_onvalidation(form):
    form.vars.emails = IS_LIST_OF_EMAILS.split_emails.findall(form.vars.emails)
```

参数的效果`represent`（在第 6 行和第 7 行）是在 HTML 页面中呈现记录时向每个电子邮件地址添加“mailto:...”链接。

##### `ANY_OF`

这个验证器接受一个验证器列表并接受一个值，如果列表中的任何验证器这样做（即，它就给定的验证器而言就像一个逻辑或）。

```
requires = ANY_OF([IS_ALPHANUMERIC(), IS_EMAIL()])
```

当没有验证器接受您从最后一次尝试的验证器（列表中的最后一个）中获得错误消息的值时，您可以像往常一样自定义错误消息：

```
>>> ANY_OF([IS_ALPHANUMERIC(), IS_EMAIL()])('@ab.co')
('@ab.co', 'Enter a valid email address')
>>> ANY_OF([IS_ALPHANUMERIC(), IS_EMAIL()],
...        error_message='Enter login or email')('@ab.co')
('@ab.co', 'Enter login or email')
```

##### `IS_IMAGE`

此验证器检查通过文件输入上传的文件是否以选定的图像格式之一保存，并且尺寸（宽度和高度）是否在给定限制内。

它不检查最大文件大小（为此使用 IS_LENGTH）。如果没有上传数据，则返回验证失败。它支持文件格式 BMP、GIF、JPEG、PNG，并且不需要 Python 图像库。

代码部分取自参考。[[来源1](http://web2py.com/books/default/reference/29/source1) ]

它采用以下参数：

- extensions：可迭代，包含允许的小写图像文件扩展名
- maxsize：可迭代的包含图像的最大宽度和高度
- minsize：可迭代的包含图像的最小宽度和高度

使用 (-1, -1) 作为 minsize 绕过图像大小检查。

这里有些例子：

- 检查上传的文件是否为任何受支持的图像格式：

```
requires = IS_IMAGE()
```

- 检查上传的文件是 JPEG 还是 PNG：

```
requires = IS_IMAGE(extensions=('jpeg', 'png'))
```

- 检查上传的文件是否为最大大小为 200x200 像素的 PNG：

```
requires = IS_IMAGE(extensions=('png'), maxsize=(200, 200))
```

- 注意：在显示包含 的表格的编辑表单时`requires = IS_IMAGE()`，`delete`不会出现复选框，因为删除文件会导致验证失败。要显示`delete`复选框，请使用此验证：

```
requires = IS_EMPTY_OR(IS_IMAGE())
```

##### `IS_FILE`

检查通过文件输入上传的文件的名称和扩展名是否与给定条件匹配。

*不*以任何方式确保文件类型。如果没有上传数据，则返回验证失败。

它的论点是：

- 文件名：字符串/编译的正则表达式或有效文件名的字符串列表/正则表达式
- 扩展名：字符串/编译的正则表达式或有效扩展名的字符串/正则表达式列表
- lastdot：应该使用哪个点作为文件名/扩展名分隔符：`True`表示最后一个点（例如，“file.tar.gz”将在“file.tar”+“gz”中被破坏）而`False`表示第一个点（例如，“file .tar.gz" 将被分解为 "file" + "tar.gz")。
- case: 0 表示保留案例；1 表示将字符串转换为小写（默认）；2 表示将字符串转换为大写。

如果不存在点，将对空字符串进行扩展检查，并对整个值进行文件名检查。

示例：检查文件是否具有 pdf 扩展名（不区分大小写）：

```
INPUT(_type='file', _name='name',
        requires=IS_FILE(extension='pdf'))
        
```

检查文件是否称为“缩略图”并具有 jpg 或 png 扩展名（不区分大小写）：

```
INPUT(_type='file', _name='name',
        requires=IS_FILE(filename='thumbnail',
        extension=['jpg', 'png']))
```

检查文件是否具有以备份开头的 tar.gz 扩展名和名称：

```
INPUT(_type='file', _name='name',
        requires=IS_FILE(filename=re.compile('backup.*'),
        extension='tar.gz', lastdot=False))
```

检查文件是否没有与 README 匹配的扩展名和名称（区分大小写）：

```
    INPUT(_type='file', _name='name',
        requires=IS_FILE(filename='README',
        extension='', case=0)
```

##### `IS_UPLOAD_FILENAME`

这是用于检查文件的较旧实现，包括向后兼容性。对于新应用程序，请使用`IS_FILE()`.

此验证器检查通过文件输入上传的文件的名称和扩展名是否与给定条件匹配。

它不以任何方式确保文件类型。如果没有上传数据，则返回验证失败。

它的论点是：

- 文件名：文件名（点之前）正则表达式。
- 扩展名：扩展名（点后）正则表达式。
- lastdot：应该使用哪个点作为文件名/扩展名分隔符：`True`表示最后一个点（例如，“file.tar.gz”将在“file.tar”+“gz”中被破坏）而`False`表示第一个点（例如，“file .tar.gz" 将被分解为 "file" + "tar.gz")。
- case: 0 表示保留案例；1 表示将字符串转换为小写（默认）；2 表示将字符串转换为大写。

如果不存在点，将对空字符串进行扩展检查，并对整个值进行文件名检查。

例子：

检查文件是否具有 pdf 扩展名（不区分大小写）：

```
requires = IS_UPLOAD_FILENAME(extension='pdf')
```

检查文件是否具有以备份开头的 tar.gz 扩展名和名称：

```
requires = IS_UPLOAD_FILENAME(filename='backup.*', extension='tar.gz', lastdot=False)
```

检查文件是否没有与 README 匹配的扩展名和名称（区分大小写）：

```
requires = IS_UPLOAD_FILENAME(filename='^README$', extension='^$', case=0)
```

##### `IS_IPV4`

此验证器检查字段的值是否为十进制形式的 IP 版本 4 地址。可以设置为从某个范围强制地址。

IPv4 正则表达式取自 ref。[[正则表达式库](http://web2py.com/books/default/reference/29/regexlib)]

`IS_IPV4`构造函数的签名如下：

```
IS_IPV4(minip='0.0.0.0', maxip='255.255.255.255', invert=False,
        is_localhost=None, is_private=None, is_automatic=None,
        error_message='Enter valid IPv4 address')
```

在哪里：

- `minip`是允许的最低地址
- `maxip`是允许的最高地址
- `invert`是一个反转允许地址范围的标志，即如果设置为 True，则只允许来自给定范围之外的地址；请注意，范围边界不以这种方式匹配

您可以将 IP 地址作为字符串（例如 '192.168.0.1'）或 4 个整数的列表或元组（例如 [192, 168, 0, 1]）传递。

要检查多个地址范围传递到边界地址`minip`的`maxip`列表或元组，例如只允许“192.168.20.10”和“192.168.20.19”之间或“192.168.30.100”和“192.168.30.199”之间的地址，请使用：

```
requires = IS_IPV4(minip=('192.168.20.10', '192.168.30.100'),
                   maxip=('192.168.20.19', '192.168.30.199'))
```

> 请注意，仅配置了同时设置了下限和上限的范围，即配置范围的数量由传递给`minip`和的迭代中的较短者确定`maxip`。

参数`is_localhost`、`is_private`和`is_automatic`接受以下值：

- `None`忽略该选项
- `True`强制选择
- `False`禁止选项

选项含义如下：

- `is_localhost`：匹配本地主机地址（127.0.0.1）
- `is_private`: 匹配 172.16.0.0 - 172.31.255.255 和 192.168.0.0 - 192.168.255.255 范围内的地址
- `is_automatic`: 匹配 169.254.0.0 - 169.254.255.255 范围内的地址

例子：

检查有效的 IPv4 地址：

```
requires = IS_IPV4()
```

检查有效的专用网络 IPv4 地址：

```
requires = IS_IPV4(minip='192.168.0.1', maxip='192.168.255.255')
```

##### `IS_IPV6`

此验证器检查字段的值是否为 IP 版本 6 地址。

`IS_IPV6`构造函数的签名如下：

```
IS_IPV6(is_private=None,
        is_link_local=None,
        is_reserved=None,
        is_multicast=None,
        is_routeable=None,
        is_6to4=None,
        is_teredo=None,
        subnets=None,
        error_message='Enter valid IPv6 address')
```

参数`is_private`, `is_link_local`, `is_reserved`, `is_multicast`, `is_routeable`, `is_6to4`, 和`is_teredo`接受以下值：

- `None`忽略该选项
- `True`强制选择
- `False`禁止该选项，这不适用于`is_routeable`

选项含义如下：

- `is_private`: 匹配分配给私有网络的地址
- `is_link_local`: 匹配为链接本地保留的地址（即在 fe80::/10 范围内），这也是一个私有网络（也与`is_private`上面匹配）
- `is_reserved`: 匹配一个地址，否则 IETF 保留
- `is_multicast`: 匹配为多播使用保留的地址（即在 ff00::/8 范围内）
- `is_6to4`: 匹配似乎包含 6to4 嵌入地址的地址（即在 2002::/16 范围内）
- `is_teredo`: 匹配一个 teredo 地址（即在 2001::/32 范围内）

强制`is_routeable`（设置为 True）是禁止（设置为 False）、 和所有的`is_private`快捷`is_reserved`方式`is_multicast`。

使用`subnets`参数传递子网或子网列表来检查地址成员资格，这样地址必须是子网成员才能验证。

例子：

检查有效的 IPv6 地址：

```
requires = IS_IPV6()
```

检查有效的专用网络 IPv6 地址：

```
requires = IS_IPV6(is_link_local=True)
```

检查子网中的有效 IPv6 地址：

```
requires = IS_IPV6(subnets='fb00::/8')
```

##### `IS_IPADDRESS`

此验证器检查字段的值是否为 IP 地址（版本 4 或版本 6）。可以设置为从特定范围内强制地址。检查是使用适当的`IS_IPV4`或`IS_IPV6`验证器完成的。

`IS_IPADDRESS`构造函数的签名如下：

```
IS_IPADDRESS(minip='0.0.0.0', maxip='255.255.255.255', invert=False,
             is_localhost=None, is_private=None, is_automatic=None,
             is_ipv4=None,
             is_link_local=None, is_reserved=None, is_multicast=None,
             is_routeable=None, is_6to4=None, is_teredo=None,
             subnets=None, is_ipv6=None,
             error_message='Enter valid IP address')
```

关于`IS_IPV4`和`IS_IPV6`验证器，唯一添加的参数是：

- `is_ipv4`, 设置为 True 以强制版本 4 或设置为 False 以禁止版本 4
- `is_ipv6`, 设置为 True 以强制版本 6 或设置为 False 以禁止版本 6

有关其他参数的含义，请参阅[IS_IPV4](http://web2py.com/books/default/chapter/29/07/forms-and-validators#IS_IPV4)和[IS_IPV6验证器。](http://web2py.com/books/default/chapter/29/07/forms-and-validators#IS_IPV6)

例子：

检查有效的 IP 地址（IPv4 和 IPv6）：

```
requires =  IS_IPADDRESS ()
```

检查有效的 IP 地址（仅限 IPv6）：

```
requires =  IS_IPADDRESS ( is_ipv6 = True )
```



#### 其他验证器

##### `CLEANUP`

这是一个过滤器。它永远不会失败。默认情况下，它只删除十进制 ASCII 代码不在列表 [10, 13, 32-127] 中的所有字符。它总是对值执行初始条带（即标题和尾随空白字符删除）。

```
requires = CLEANUP()
```

您可以传递正则表达式来决定必须删除的内容，例如清除所有非数字字符使用：

```
>>> CLEANUP('[^\d]')('Hello 123 world 456')
('123456', None)
```



#### 数据库验证器

##### `IS_NOT_IN_DB`

###### 概要：

```
IS_NOT_IN_DB(db|set, 'table.field')
```

考虑以下示例：

```
db.define_table('person', Field('name'))
db.person.name.requires = IS_NOT_IN_DB(db, 'person.name')
```

它要求当您插入一个新人时，他/她的名字不在数据库中`db`，在字段中`person.name`。

可以使用 set 来代替`db`.

与所有其他验证器一样，此要求是在表单处理级别而非数据库级别强制执行的。这意味着，如果两个访问者尝试同时插入具有相同 person.name 的记录，这将导致竞争条件并且两条记录都被接受，这有很小的可能性。因此，通知数据库该字段应具有唯一值更安全：

```
db.define_table('person', Field('name', unique=True))
db.person.name.requires = IS_NOT_IN_DB(db, 'person.name')
```

现在，如果发生竞争条件，数据库将引发 OperationalError，并且两个插入之一被拒绝。

的第一个参数`IS_NOT_IN_DB`可以是数据库连接或 Set。在后一种情况下，您将只检查由 Set 定义的集合。

的完整参数列表`IS_NOT_IN_DB()`如下：

```
IS_NOT_IN_DB(dbset, field, error_message='value already in database or empty',
             allowed_override=[], ignore_common_filters=True)
```

例如，下面的代码不允许两个同名的人在 10 天内注册：

```
import datetime
now = datetime.datetime.today()
db.define_table('person',
    Field('name'),
    Field('registration_stamp', 'datetime', default=now))
recent = db(db.person.registration_stamp > now-datetime.timedelta(10))
db.person.name.requires = IS_NOT_IN_DB(recent, 'person.name')
```

##### `IS_IN_DB`



###### 概要：

```
IS_IN_DB(db|set, 'table.value_field', '%(representing_field)s', zero='choose one')
```

其中第三个和第四个参数是可选的。

`multiple=`如果字段类型是列表，也是可能的。默认值为假。它可以设置为 True 或元组 (min, max) 以限制所选值的数量。因此`multiple=(1, 10)`强制执行至少一个且最多十个选择。

其他可选参数将在下面讨论。

###### 例子

考虑以下表格和要求：

```
db.define_table('person', Field('name', unique=True))
db.define_table('dog', Field('name'), Field('owner', db.person))
db.dog.owner.requires = IS_IN_DB(db, 'person.id', '%(name)s',
                                 zero=T('choose one'))
```

也可以编写 IS_IN_DB 要求以使用 Set 而不是 db

```
db.dog.owner.requires = IS_IN_DB(db(db.person.id > 10), 'person.id', '%(name)s',
                                 zero=T('choose one'))
```

它在狗 INSERT/UPDATE/DELETE 表单级别强制执行。此示例要求 a是数据库`dog.owner`字段中的有效 id 。由于这个验证器，该字段被表示为一个下拉列表。验证器的第三个参数是一个描述下拉列表中元素的字符串，它被传递给验证器的参数。在示例中，您希望查看 person而不是 person 。替换为每条记录的括号中字段的值。其他可接受的值是 Field 实例（例如，您可以使用 db.person.name 而不是 '%(name)s'），甚至是一个可调用的，它采用一行并返回选项的描述。`person.id``db``dog.owner``label``%(name)s``%(id)s``%(...)s``label`

该`zero`选项非常适用于`IS_IN_SET`验证器。

其他接受的可选参数`IS_IN_DB`有：`orderby`, `groupby`, `distinct`, `cache`, 和`left`，它们被传递给 db select （有关它们的含义，请参见[第 6 章](http://web2py.com/books/default/chapter/29/06##orderby-groupby-limitby-distinct-having-orderby_on_limitby-left-cache)）。

> 请注意`groupby`，`distinct`、 和`left`不适用于 Google App Engine。

要按字母顺序对下拉列表中列出的选项进行排序，您可以将`sort`参数设置为`True`（排序不区分大小写），这在 no`orderby`可行或实用时可能很有用。

验证器的第一个参数可以是数据库连接或 DAL 集，如`IS_NOT_IN_DB`. 例如，当希望限制下拉列表中的记录时，这可能很有用。在此示例中，我们在控制器中使用`IS_IN_DB`以在每次调用控制器时动态限制记录：

```
def index():
    (...)
    query = (db.table.field == 'xyz') # in practice 'xyz' would be a variable
    db.table.field.requires = IS_IN_DB(db(query), ...)
    form = SQLFORM(...)
    if form.process().accepted: ...
    (...)
```

如果您希望验证字段，但不希望下拉列表，则必须将验证器放在列表中。

```
db.dog.owner.requires = [IS_IN_DB(db, 'person.id', '%(name)s')]
```

有时您需要下拉列表（因此您不想使用上面的列表语法）但您想使用其他验证器。为此，`IS_IN_DB`验证器采用一个额外的参数`_and`，如果验证值通过验证，则该参数可以指向应用的其他验证器列表`IS_IN_DB`。例如，验证 db 中所有不在子集中的狗主人：

```
subset = db(db.person.id > 100)
db.dog.owner.requires = IS_IN_DB(db, 'person.id', '%(name)s',
                                 _and=IS_NOT_IN_DB(subset, 'person.id'))                         
```

##### `IS_IN_DB`和标记

验证器`IS_IN_DB`有一个可选属性`multiple=False`。如果设置为`True`多个值可以存储在一个字段中。该字段应该是[第 6 章](http://web2py.com/books/default/chapter/29/06#list-type-and-contains)`list:reference`中讨论的类型。那里讨论了一个明确的标记示例。多个引用在创建和更新表单中自动处理，但它们对 DAL 是透明的。我们强烈建议使用 jQuery 多选插件来呈现多个字段。



#### 自定义验证器

所有验证器都遵循以下原型：

```
class sample_validator:
    def __init__(self, *a, error_message='error'):
        self.a = a
        self.e = error_message
    def __call__(self, value):
        if validate(value):
            return (parsed(value), None)
        return (value, self.e)
    def formatter(self, value):
        return format(value)
```

即，当调用验证值时，验证器返回一个元组`(x, y)`。如果`y`是`None`，则该值通过验证并`x`包含解析值。例如，如果验证器要求值是整数，`x`则转换为`int(value)`. 如果该值未通过验证，则`x`包含输入值并`y`包含解释验证失败的错误消息。此错误消息用于报告未验证的表单中的错误。

> 请注意，作为自定义验证器的替代方案，您还可以使用`onvalidation`form 、 和 methods 的参数`accepts`（`process`请`validate`参阅[onvalidation](http://web2py.com/books/default/chapter/29/07/forms-and-validators#onvalidation)部分）。

验证器也可能包含一个`formatter`方法。它必须执行与所做的相反的转换`__call__`。例如，考虑以下的源代码`IS_DATE`：

```
class IS_DATE(object):
    def __init__(self, format='%Y-%m-%d', error_message='must be YYYY-MM-DD!'):
        self.format = format
        self.error_message = error_message
    def __call__(self, value):
        try:
            y, m, d, hh, mm, ss, t0, t1, t2 = time.strptime(value, str(self.format))
            value = datetime.date(y, m, d)
            return (value, None)
        except:
            return (value, self.error_message)
    def formatter(self, value):
        return value.strftime(str(self.format))
```

成功时，该`__call__`方法从表单中读取日期字符串，并使用构造函数中指定的格式字符串将其转换为 datetime.date 对象。该`formatter`方法采用 datetime.date 对象并将其转换为使用相同格式的字符串表示形式。会在`formatter`表单中自动调用，但您也可以显式调用它以将对象转换为正确的表示形式。例如：

```
>>> db = DAL()
>>> db.define_table('atable',
       Field('birth', 'date', requires=IS_DATE('%m/%d/%Y')))
>>> id = db.atable.insert(birth=datetime.date(2008, 1, 1))
>>> row = db.atable[id]
>>> print db.atable.birth.formatter(row.birth)
01/01/2008
```



#### 多个验证器

通常，当需要多个验证器（并存储在一个列表中）时，它们会按顺序执行，其中一个的输出作为输入传递给下一个。当其中一个验证者失败时，链会中断。

相反，当我们调用`formatter`字段的方法时，相关验证器的格式化程序也被链接起来，但顺序相反。

作为上述链接行为的替代方案，`ANY_OF`验证器可用于组合验证器列表，并在**任何**验证器通过时通过（有关详细信息，请参阅[ANY_OF](http://web2py.com/books/default/chapter/29/07/forms-and-validators#ANY_OF)部分）。



#### 具有依赖关系的验证器

通常验证器在模型中设置一次。

有时，您需要验证一个字段，而验证器依赖于另一个字段的值。这可以通过多种方式完成。它可以在模型或控制器中完成。

例如，这是一个生成注册表单的页面，该表单要求输入用户名和密码两次。任何字段都不能为空，并且两个密码必须匹配：

```
def index():
    form = SQLFORM.factory(
        Field('username', requires=IS_NOT_EMPTY()),
        Field('password', requires=IS_NOT_EMPTY()),
        Field('password_again',
              requires=IS_EQUAL_TO(request.vars.password)))
    if form.process().accepted:
        pass # or take some action
    return dict(form=form)
```



### 小部件

以下是可用 web2py 小部件的列表：

```
SQLFORM.widgets.string.widget
SQLFORM.widgets.text.widget
SQLFORM.widgets.password.widget
SQLFORM.widgets.integer.widget
SQLFORM.widgets.double.widget
SQLFORM.widgets.time.widget
SQLFORM.widgets.date.widget
SQLFORM.widgets.datetime.widget
SQLFORM.widgets.upload.widget
SQLFORM.widgets.boolean.widget
SQLFORM.widgets.options.widget
SQLFORM.widgets.multiple.widget
SQLFORM.widgets.radio.widget
SQLFORM.widgets.checkboxes.widget
SQLFORM.widgets.autocomplete
SQLFORM.widgets.list
```

其中前十个加上“列表”是相应字段类型的默认值。当字段的 requires is`IS_IN_SET`或`IS_IN_DB`with `multiple=False`（默认行为）时，使用“选项”小部件。当字段的 requires is`IS_IN_SET`或`IS_IN_DB`with时使用“multiple”小部件`multiple=True`。默认情况下从不使用“收音机”和“复选框”小部件，但可以手动设置。“自动完成”小部件很特别，在其自己的部分中进行了讨论。

例如，要有一个由 textarea 表示的“字符串”字段：

```
Field('comment', 'string', widget=SQLFORM.widgets.text.widget)
```

小部件也可以分配给*后验*字段：

```
db.mytable.myfield.widget = SQLFORM.widgets.string.widget
```

有时小部件需要额外的参数，并且需要指定它们的值。在这种情况下，可以使用`lambda`

```
db.mytable.myfield.widget = lambda field, value: \
    SQLFORM.widgets.string.widget(field, value, _style='color:blue')
```

小部件是辅助工厂，它们的前两个参数始终是`field`和`value`。其他参数可以包括普通的辅助属性，例如`_style`,`_class`等。一些小部件也采用特殊参数。特别是接受一个参数（不要`SQLFORM.widgets.radio`与混淆），它可以设置为“table”、“ul”、“divs”或与包含表单的匹配的任何内容。`SQLFORM.widgets.checkboxes``style``_style``formstyle`

您可以创建新的小部件或扩展现有的小部件。

`SQLFORM.widgets[type]`是一个类，`SQLFORM.widgets[type].widget`是对应类的静态成员函数。每个小部件函数都有两个参数：字段对象和该字段的当前值。它返回小部件的表示。例如，字符串小部件可以重新编码如下：

```
def my_string_widget(field, value):
    return INPUT(_name=field.name,
                 _id="%s_%s" % (field.tablename, field.name),
                 _class=field.type,
                 _value=value,
                 requires=field.requires)

Field('comment', 'string', widget=my_string_widget)
```

id 和 class 值必须遵循本章后面描述的约定。小部件可能包含它自己的验证器，但最好将验证器与字段的“requires”属性相关联并让小部件从那里获取它们。



#### 自动完成小部件

自动完成小部件有两种可能的用途：自动完成从列表中获取值的字段或自动完成引用字段（其中要自动完成的字符串是引用的表示，它被实现为 id）。

第一种情况很简单：

```
db.define_table('category', Field('name'))
db.define_table('product', Field('name'), Field('category'))
db.product.category.widget = SQLFORM.widgets.autocomplete(
     request, db.category.name, limitby=(0, 10), min_length=2)
```

Where`limitby`指示小部件一次显示不超过 10 个建议，并`min_length`指示小部件执行 Ajax 回调以仅在用户在搜索框中键入至少 2 个字符后获取建议。以这种方式使用时，您可以避免重复建议设置可选参数`distinct=True`。

> 请注意，在上面的示例中，两个参数`limitby=(0, 10)`和`min_length=2`都可以省略，因为它们的默认值。
>
> 请注意，`distinct`自动完成虚拟字段时不起作用（请参阅[第 6 章](http://web2py.com/books/default/chapter/29/06#New-style-virtual-fields)了解虚拟字段）。

第二种情况更复杂：

```
db.define_table('category', Field('name'))
db.define_table('product', Field('name'), Field('category', 'reference category'))
db.product.category.widget = SQLFORM.widgets.autocomplete(
     request, db.category.name, id_field=db.category.id)
```

在这种情况下， 的值`id_field`告诉小部件即使要自动完成的值是 a `db.category.name`，要存储的值也是对应的`db.category.id`。一个可选参数是`orderby`指示小部件如何对建议进行排序，例如让它们按字母顺序排序使用：

```
db.product.category.widget = SQLFORM.widgets.autocomplete(
     request, db.category.name, id_field=db.category.id,
     orderby=db.category.name)
```

在这种情况下，您不能使用`distinct=True`来避免重复建议，因为在自动完成参考字段时也会选择 id_field （有关详细信息，请参阅[第 6 章](http://web2py.com/books/default/chapter/29/06#distinct)）。

在寻找建议时，小部件通常在字段值的开头匹配，以让小部件在任何地方匹配（即执行搜索）设置可选参数`at_beginning=False`。

> 请注意，在 Google App Engine 上两者都`distinct=True`不起作用`at_beginning=False`。

这个小部件通过 Ajax 工作。Ajax 回调在哪里？这个小部件中正在发生一些魔法。回调是小部件对象本身的方法。它是如何暴露的？在 web2py 中，任何一段代码都可以通过引发 HTTP 异常来生成响应。这个小部件通过以下方式利用这种可能性：小部件将 Ajax 调用发送到最初生成小部件的同一个 URL，并在 request.vars 中放置一个特殊标记。如果小部件再次实例化，它会找到令牌并引发响应请求的 HTTP 异常。所有这些都是在引擎盖下完成的，并且对开发人员隐藏。

为了增强安全性，自动完成小部件可以对 Ajax 回调进行数字签名，这是通过`user_signature`和`hash_vars`参数完成的，请参阅[第 4 章](http://web2py.com/books/default/chapter/29/04#Digitally-signed-urls)中的解释。



### `SQLFORM.grid`和`SQLFORM.smartgrid`

> 注意：grid 和 smartgrid 是 web2py 2.0 之前的实验性版本，容易受到信息泄露的影响。网格和智能网格不再是实验性的，但我们仍然不承诺网格表示层的向后兼容性，只承诺其 API。

这是两个创建复杂 CRUD 控件的高级对象。它们提供分页、浏览、搜索、排序、创建、更新和删除单个对象中的记录的能力。

因为 web2py 的 HTML 对象建立在底层的、更简单的对象之上，所以网格创建 SQLFORM 用于查看、编辑和创建其行。网格的许多参数都传递给这个 SQLFORM。这意味着 SQLFORM（和 FORM）的文档是相关的。例如，网格接受`onvalidation`回调。网格的处理逻辑最终将其传递给 FORM 的底层 process() 方法，这意味着您应该查阅`onvalidation`for FORMs 的文档。

随着网格经过不同的状态，比如编辑一行，就会产生一个新的请求。request.args 包含有关网格处于哪个状态的信息。



### `SQLFORM.grid`

两者中最简单的是`SQLFORM.grid`. 这是一个使用示例：

```
@auth.requires_login()
def manage_users():
    grid = SQLFORM.grid(db.auth_user)
    return locals()
```

这会产生以下页面：



![图片](http://web2py.com/books/default/image/29/en6700.png)



的第一个参数`SQLFORM.grid`可以是表或查询。网格对象将提供对匹配查询的记录的访问。

在我们深入研究网格对象的一长串参数之前，我们需要了解它是如何工作的。对象查看`request.args`是为了决定做什么（浏览、搜索、创建、更新、删除等）。对象创建的每个按钮都链接相同的功能（`manage_users`在上述情况下）但传递不同的`request.args`.



#### 数据更新默认需要登录

默认情况下，网格生成的所有 URL 都经过数字签名和验证。这意味着一个人不能在没有登录的情况下执行某些操作（创建、更新、删除）。这些限制可以放宽：

```
def manage_users():
    grid = SQLFORM.grid(db.auth_user, user_signature=False)
    return locals()
```

但我们不推荐它。



#### 每个控制器功能多个网格

> 由于网格的工作方式，每个控制器功能只能有一个网格，除非它们通过`LOAD`. 要使默认搜索网格在多个已加载网格中工作，请`formname`为每个网格使用不同的。



#### 安全地使用 requests.args

因为包含网格的控制器函数本身可能会操纵 URL 参数（在 web2py 中称为 response.args 和 response.vars），所以网格需要知道哪些参数应该由网格处理，哪些不应该。这是一个允许管理任何表的代码示例：

```
@auth.requires_login()
def manage():
    table = request.args(0)
    if not table in db.tables(): redirect(URL('error'))
    grid = SQLFORM.grid(db[table], args=request.args[:1])
    return locals()
     
```

的`args`参数`grid`指定`request.args`应该传递并被 . 忽略的参数`grid`。在我们的例子`request.args[:1]`中是我们要管理的表的名称，它由`manage`函数本身处理，而不是由`grid`. 因此，`args=request.args[:1]`告诉网格在它生成的任何链接中保留第一个 URL 参数，在第一个参数之后附加任何特定于网格的参数。



#### SQLFORM.grid 签名

网格的完整签名如下：

```
SQLFORM.grid(
    query,
    fields=None,
    field_id=None,
    left=None,
    headers={},
    orderby=None,
    groupby=None,
    searchable=True,
    sortable=True,
    paginate=20,
    deletable=True,
    editable=True,
    details=True,
    selectable=None,
    create=True,
    csv=True,
    links=None,
    links_in_grid=True,
    upload='<default>',
    args=[],
    user_signature=True,
    maxtextlengths={},
    maxtextlength=20,
    onvalidation=None,
    onfailure=None,
    oncreate=None,
    onupdate=None,
    ondelete=None,
    sorter_icons=(XML('&#x25B2;'), XML('&#x25BC;')),
    ui = 'web2py',
    showbuttontext=True,
    _class="web2py_grid",
    formname='web2py_grid',
    search_widget='default',
    advanced_search=True,
    ignore_rw = False,
    formstyle = None,
    exportclasses = None,
    formargs={},
    createargs={},
    editargs={},
    viewargs={},
    selectable_submit_button='Submit',
    buttons_placement = 'right',
    links_placement = 'right',
    noconfirm=False,
    cache_count=None,
    client_side_delete=False,
    ignore_common_filters=None,
    auto_pagination=True,
    use_cursor=False,
    represent_none=None,
    showblobs=False
    )
```

- ```
  fields
  ```

  是要从数据库中获取的字段列表。它还用于确定要在网格视图中显示哪些字段。但是，它不控制用于编辑行的单独表单中显示的内容。为此，请使用数据库字段的可读和可写属性。例如，在可编辑网格中，禁止更新字段，如下所示：在创建 SQLFORM.grid 之前，设置

  ```
  db.my_table.a_field.writable = False
  db.my_table.a_field.readable = False
  ```

- `field_id`必须是要用作 ID 的表的字段，例如`db.mytable.id`. 当网格查询是多个表的连接时，这很有用。网格上的任何操作按钮（添加记录、查看、编辑、删除）都将在 db.mytable 上工作。

- `left`是一个可选的左连接表达式，用于构建`...select(left=...)`.

- `headers`是将“tablename.fieldname”映射到相应标题标签的字典，例如`{'auth_user.email' : 'Email Address'}`

- `orderby`用作行的默认排序。请参阅[第 6 章](http://web2py.com/books/default/chapter/29/06#orderby)（可能有多个字段）。

- `groupby`用于对集合进行分组。使用与传递简单`select(groupby=...)`.

- `searchable`, `sortable`, `deletable`, `editable`, `details`,`create`分别确定是否可以搜索、排序、删除、编辑、查看详细信息和创建新记录。`deletable`,`editable`并且`details`通常是布尔值，但它们可以是获取行对象并决定是否显示相应按钮的函数。

- ```
  selectable
  ```

  可用于在多条记录上调用自定义函数（将为每一行插入一个复选框），例如

  ```
  selectable = lambda ids : redirect(URL('default', 'mapping_multiple', vars=dict(id=ids)))
  ```

  将在复选框列中添加一个提交按钮，并传入标签

  ```
  selectable_submit_button
  ```

  ；或者对于多个操作按钮，使用元组列表：

  ```
  selectable =  [( 'button label1' ,  lambda ... ),  ( 'button label2' ,  lambda  ... )]
  ```

- `paginate`设置每页的最大行数。

- `csv`如果设置为 True 允许以各种格式下载网格（另见`exportclasses`下文）。

- `links`用于显示可以链接到其他页面的新列。`links`参数必须是一个列表， `dict(header='name', body=lambda row: A(...))`其中列出`header`了新列的标题，并且`body`是一个接受一行并返回一个值的函数。在示例中，该值是一个`A(...)`助手。

- `links_in_grid`如果设置为 False，链接将仅显示在“详细信息”和“编辑”页面中（因此，不在主网格上）

- `upload`与 SQLFORM 的相同。web2py 使用该 URL 处的操作来下载文件

- `maxtextlength`设置在网格视图中为每个字段值显示的最大文本长度。`maxtextlengths`可以使用'tablename.fieldname':length 的字典为每个字段覆盖此值，例如`{'auth_user.email' : 50}`

- ```
  onvalidation
  ```

  , 

  ```
  onfailure
  ```

  , 

  ```
  oncreate
  ```

  ,

  ```
  onupdate
  ```

  和

  ```
  ondelete
  ```

  是回调函数。除了

  ```
  ondelete
  ```

  将表单对象作为输入之外，ondelete 都使用表和记录 ID。因为编辑/创建表单是扩展 FORM 的 SQLFORM，所以这些回调的使用方式基本上与 FORM 和 SQLFORM 部分中记录的方式相同。这是骨架代码：

  ```
  def myonvalidation(form):
      print "In onvalidation callback"
      print form.vars
      form.errors= True  #this prevents the submission from completing
      
      #...or to add messages to specific elements on the form
      form.errors.first_name = "Do not name your child after prominent deities"	
      form.errors.last_name = "Last names must start with a letter"
      response.flash = "I don't like your submission" 
  
  def myonfailure(form):
      print 'edit/create validation problem'
      print form.errors
  
  def myoncreate(form):
      print 'create!'
      print form.vars
  
  def myonupdate(form):
      print 'update!'
      print form.vars
  
  def myondelete(table, id):
      print 'delete!'
      print table, id
  ```

  ```
  onupdate
  ```

  并将

  ```
  oncreate
  ```

  回调传递给

  ```
  SQLFORM.process(onsuccess=...)
  ```

  .

- `sorter_icons`是两个字符串（或助手）的列表，将用于表示每个字段的向上和向下排序选项。

- ```
  ui
  ```

  可以设置为

  ```
  'web2py'
  ```

  （默认）并生成 web2py 友好的类名，可以设置为等于

  ```
  'jquery-ui'
  ```

  并生成 jquery UI 友好的类名，但它也可以是各种网格组件自己的一组类名：

  ```
  ui = dict(
      widget='',
      header='',
      content='',
      default='',
      cornerall='',
      cornertop='',
      cornerbottom='',
      button='button',
      buttontext='buttontext button',
      buttonadd='icon plus',
      buttonback='icon leftarrow',
      buttonexport='icon downarrow',
      buttondelete='icon trash',
      buttonedit='icon pen',
      buttontable='icon rightarrow',
      buttonview='icon magnifier')
  ```

- `search_widget`允许覆盖默认搜索小部件，我们向读者推荐 gluon/sqlhtml.py 中的源代码以获取详细信息。

- `advanced_search`如果设置为 False，则在搜索小部件上禁用高级搜索功能

- `showbuttontext`允许没有文本的按钮（实际上只有图标）

- `_class`是网格容器的类。

- ```
  exportclasses
  ```

  接受一个元组字典：默认情况下它被定义为

  ```
  dict(
    csv_with_hidden_cols=(ExporterCSV_hidden, 'CSV (hidden cols)', T(...)),
    csv=(ExporterCSV, 'CSV', T(...)),
    xml=(ExporterXML, 'XML', T('XML export of columns shown')),
    html=(ExporterHTML, 'HTML', T('HTML export of visible columns')),
    json=(ExporterJSON, 'JSON', T('JSON export of visible columns')),
    tsv_with_hidden_cols=
        (ExporterTSV, 'TSV (Spreadsheets, hidden cols)', T(...)),
    tsv=(ExporterTSV, 'TSV (Spreadsheets)', T(...)))
  ```

  ExporterCSV_hidden、ExporterCSV、ExporterXML、ExporterHTML、ExporterJSON 和 ExporterTSV 都在 gluon/sqlhtml.py 中定义。看看那些用于创建自己的出口商的东西。如果你传递一个像你这样的字典，

  ```
  dict(xml=False, html=False)
  ```

  你将禁用 xml 和 html 导出格式。

- `formargs`传递给网格使用的所有 SQLFORM 对象，而`createargs`和`editargs`仅`viewargs`传递给特定的创建、编辑和详细信息 SQLFORM

- `formname`,`ignore_rw`并`formstyle`传递给网格用于创建/更新表单的 SQLFORM 对象。

- `buttons_placement`并且`links_placement`都带有一个参数（'right'，'left'，'both'），这将影响按钮（或链接）在行上的放置位置

- `noconfirm`如果设置为 True，则在删除记录时不需要用户确认。

- `cache_count`用于加速网格行数，它可以缓存选择查询（在这种情况下，您传递一个元组作为 的`cache`参数`select`，请参阅[第 6 章](http://web2py.com/books/default/chapter/29/06#Caching-selects)），或者直接提供行数（即整数或可调用返回整数计数）。

- `client_side_delete`如果设置为 True，则需要在 Ajax 上删除时重新加载网格（即，将 的值`client_side_delete`传递给 的`client_side`参数`redirect`，另请参见[第 4 章](http://web2py.com/books/default/chapter/29/04#HTTP-and-redirect)）。

- `ignore_common_filters`可以设置为 True 用于在网格数据库集定义时（即在评估查询时）抑制常见的过滤器。常见的过滤器在[第 6 章](http://web2py.com/books/default/chapter/29/06#Common-filters)中描述。

- `auto_pagination`如果设置为 True 始终强制对记录进行排序以避免分页问题。

- `use_cursor`仅特定于 Google NoSQL (Datastore)，如果设置为 True，则允许使用光标进行分页。

- `represent_none`是在网格/详细信息视图中显示记录时使用的可选值，而不是 None。

- `showblobs`如果设置为 True 告诉网格显示`blob`类型的字段，默认情况下不显示。



#### SQLFORM.grid 和 smartgrid 中的虚拟字段

在 2.6 之后的 web2py 版本中，虚拟字段像普通字段一样显示在网格中：默认情况下与所有其他字段一起显示，或者将它们包含在`fields`参数中。但是，虚拟字段不可排序。

在较旧的 web2py 版本中，在网格中显示虚拟字段需要使用`links`参数。更新的版本仍然支持此功能。如果表 db.t1 有一个名为 t1.vfield 的字段，它基于 t1.field1 和 t1.field2 的值，请执行以下操作：

```
grid = SQLFORM.grid(db.t1, ..., fields = [t1.field1, t1.field2, ...],
   links = [dict(header='Virtual Field 1', body=lambda row:row.vfield), ...] )
```

在所有情况下，因为 t1.vfield 依赖于 t1.field1 和 t1.field2，所以这些字段必须存在于行中。在上面的示例中，这是通过在参数中包含 t1.field1 和 t1.field2 来保证的`fields`。或者，显示所有字段也可以。`readable`您可以通过将属性设置为 False来禁止显示字段。

请注意，在定义虚拟字段时，lambda 函数必须使用表名限定字段，但在 links 参数中，这不是必需的。因此，对于上面的示例，虚拟字段可以定义为：

```
db.define_table('t1', Field('field1', 'string'),
   Field('field2', 'string'),
   Field.Virtual('vfield', lambda row: row.t1.field1 + row.t1.field2),
   ...)
```



#### SQLFORM.smartgrid

A`SQLFORM.smartgrid`看起来很像 a `grid`，实际上它包含一个网格，但它的设计目的不是将查询而是一个表作为输入，并浏览所述表和选定的引用表。

例如考虑下面的表结构：

```
db.define_table('parent', Field('name'))
db.define_table('child', Field('name'), Field('parent', 'reference parent'))
```

使用 SQLFORM.grid 您可以列出所有父母：

```
SQLFORM.grid(db.parent)
```

所有孩子：

```
SQLFORM.grid(db.child)
```

和所有父母和孩子在一张桌子上：

```
SQLFORM.grid(db.parent, left=db.child.on(db.child.parent==db.parent.id))
```

使用 SQLFORM.smartgrid，您可以将所有数据放在一个生成两个表的对象中：

```
@auth.requires_login()
def manage():
    grid = SQLFORM.smartgrid(db.parent, linked_tables=['child'])
    return locals()
```

看起来像这样：



![图片](http://web2py.com/books/default/image/29/en6800.png)



注意额外的“孩子”链接。`links`可以使用常规创建额外内容，`grid`但它们会指向不同的操作。使用 a`smartgrid`它们会自动创建并由同一对象处理。

另请注意，当单击给定父级的“子级”链接时，只会获取该父级的子级列表（这很明显），但还要注意，如果现在尝试添加新子级，则父级的值新子代会自动设置为选定的父代（显示在与对象关联的面包屑中）。该字段的值可以被覆盖。我们可以通过使其只读来防止这种情况：

```
@auth.requires_login()
def manage():
    db.child.parent.writable = False
    grid = SQLFORM.smartgrid(db.parent, linked_tables=['child'])
    return locals()
```

如果`linked_tables`未指定参数，则所有引用表都会自动链接。无论如何，为避免意外暴露数据，我们建议明确列出应链接的表。

以下代码为系统中的所有表创建了一个非常强大的管理界面：

```
@auth.requires_membership('managers')
def manage():
    table = request.args(0) or 'auth_user'
    if not table in db.tables(): redirect(URL('error'))
    grid = SQLFORM.smartgrid(db[table], args=request.args[:1])
    return locals()
```



#### 智能电网签名

采用`smartgrid`与 a 相同的论点，`grid`但有一些注意事项：

- 第一个参数是表，而不是查询
- 还有一个额外的参数`constraints`是'tablename'的字典：查询可用于进一步限制对'tablename'网格中显示的记录的访问。
- 有一个额外的参数`linked_tables`是应该通过智能网格访问的表的表名列表。
- `divider`允许指定在面包屑导航器中使用的字符，`breadcrumbs_class`将类应用于面包屑元素
- 除了表格、`args`、`linked_tables`、`links_in_grid`和之外的所有参数`user_signature`都可以是字典，如下所述。

考虑前面的网格：

```
grid = SQLFORM.smartgrid(db.parent, linked_tables=['child'])
```

它允许访问 a`db.parent`和 a `db.child`。除了导航控件，对于每一个表格，智能网格只不过是一个网格。这意味着，在这种情况下，一个智能网格可以为父级创建一个网格，为子级创建一个网格。我们可能希望将不同的参数集传递给这些网格。例如不同的`searchable`参数集。

而对于网格，我们将传递一个布尔值：

```
grid = SQLFORM.grid(db.parent, searchable=True)
```

对于智能电网，我们将传递一个布尔字典：

```
grid = SQLFORM.smartgrid(db.parent, linked_tables=['child'],
     searchable= dict(parent=True, child=False))
```

通过这种方式，我们使父母可以搜索，但每个父母的孩子不可搜索（不应该有那么多需要搜索小部件）。



#### 电网和智能电网访问控制

`grid`并且`smartgrid`不会像 crud 那样自动强制执行访问控制，但您可以将其与`auth`使用显式权限检查集成：

```
grid = SQLFORM.grid(db.auth_user,
     editable = auth.has_membership('managers'),
     deletable = auth.has_membership('managers'))
```

要么

```
grid = SQLFORM.grid(db.auth_user,
     editable = auth.has_permission('edit', 'auth_user'),
     deletable = auth.has_permission('delete', 'auth_user'))
```



#### 智能电网复数

`smartgrid`是 web2py 中唯一显示表名的对象，它需要单数和复数。例如，一位父母可以有一个“孩子”或多个“孩子”。因此，表对象需要知道自己的单复数名称。web2py 通常会猜到它们，但您可以显式设置它们：

```
db.define_table('child', ..., singular="Child", plural="Children")
```

或与：



```
db.define_table('child', ...)
db.child._singular = "Child"
db.child._plural = "Children"
```

它们还应该使用`T`运算符进行国际化。

然后使用复数和单数`smartgrid`来为标题和链接提供正确的名称。