## 部署：开发和生产





### 应用配置模块

您的开发和生产系统之间的环境几乎肯定意味着不同的数据库配置、不同的邮件服务器以及可能的其他差异。

Web2py 打算使用私有目录来存储在典型部署中不会复制到生产环境中的信息（尽管您需要注意确保您没有部署该目录）。

贡献的模块`AppConfig`允许私有目录存储一个简单的配置文本文件，以定义在开发和生产之间变化的设置，例如数据库连接。默认情况下，它是一个 Python 风格的文本文件，但也支持 json。

欢迎应用程序现在使用此模块`db.py`从应用程序私有目录中的文件中读取配置。默认情况下，此文件的路径是

```
private/appconfig.ini
```

默认情况下，`appconfig.ini`允许您定义数据库连接和 smtp 配置。当应用程序稳定时，可以将模块设置为缓存模式以减少开销。

```
from gluon.contrib.appconfig import AppConfig
...
myconf = AppConfig(reload=False)
```

在最新版本的 web2py 中创建的应用程序默认使用 AppConfig 定义数据库连接。

app_config.ini 中的值通过如下方式从字符串值中获取和转换：

```
myconf = AppConfig()
...
a_config_value = myconf.take('example_section.example_key', cast=int)	
```

因为转换发生在字符串中，并且非空字符串转换为 True，所以表示布尔 False 的最安全方法是使用空字符串：

```
[ example_section ] 
example_key  =
```



### 部署秘籍：基础设施

在生产环境中部署 web2py 有多种方法。详细信息取决于主机提供的配置和服务。

在本章中，我们考虑以下问题：

- 生产部署（Apache、Nginx、Lighttpd、Cherokee）
- 安全
- 使用 Redis 和负载均衡器的可扩展性。
- 在 PythonAnywhere、Heroku、Amazon EC2 和 Google App Engine 平台上部署 (GAE [ [gae](http://web2py.com/books/default/reference/29/gae) ] )





web2py 带有一个启用 SSL [ [ssl](http://web2py.com/books/default/reference/29/ssl) ] 的 web 服务器，即 Rocket wsgiserver [ [rocket](http://web2py.com/books/default/reference/29/rocket) ]。虽然这是一个快速的 Web 服务器，但它的配置能力有限。出于这个原因，最好将 web2py 部署在 Apache [ [apache](http://web2py.com/books/default/reference/29/apache) ]、Nginx [ [nginx](http://web2py.com/books/default/reference/29/nginx) ] Lighttpd [ [lighttpd](http://web2py.com/books/default/reference/29/lighttpd) ] he 或 Cherokee [ [cherokee](http://web2py.com/books/default/reference/29/cherokee) ]后面. 这些是可定制的免费和开源 Web 服务器，并且已被证明在高流量生产环境中是可靠的。它们可以配置为直接提供静态文件、处理 HTTPS 并将控制权传递给 web2py 以获取动态内容。

直到几年前，Web 服务器和 Web 应用程序之间通信的标准接口还是通用网关接口 (CGI) [ [cgi](http://web2py.com/books/default/reference/29/cgi) ]。CGI 的主要问题是它为每个 HTTP 请求创建一个新进程。如果 Web 应用程序是用解释语言编写的，那么 CGI 脚本服务的每个 HTTP 请求都会启动一个新的解释器实例。这很慢，在生产环境中应该避免。此外，CGI 只能处理简单的响应。例如，它不能处理文件流。

web2py 提供了一个`cgihandler.py`与 CGI 接口的文件。

这个问题的一个解决方案是使用 Apache 的 mod_python 模块。我们在这里讨论它是因为它的使用仍然很普遍，尽管 mod_python 项目已被 Apache 软件基金会正式放弃。mod_python 在 Apache 启动时启动 Python 解释器的一个实例，并在其自己的线程中为每个 HTTP 请求提供服务，而无需每次都重新启动 Python。这是比 CGI 更好的解决方案，但不是最佳解决方案，因为 mod_python 使用自己的接口在 Web 服务器和 Web 应用程序之间进行通信。在 mod_python 中，所有托管应用程序都在相同的 user-id/group-id 下运行，这会带来安全问题。

web2py 提供了一个文件`modpythonhandler.py`来连接 mod_python。

在过去的几年里，Python 社区聚集在一起，为 Web 服务器和用 Python 编写的 Web 应用程序之间的通信提供了一个新的标准接口。它被称为 Web 服务器网关接口 (WSGI) [ [wsgi-w](http://web2py.com/books/default/reference/29/wsgi-w) ] [ [wsgi-o](http://web2py.com/books/default/reference/29/wsgi-o) ]。web2py 是基于 WSGI 构建的，它提供了在 WSGI 不可用时使用其他接口的处理程序。

Apache通过 Graham Dumpleton 开发的模块 mod_wsgi [ [modwsgi](http://web2py.com/books/default/reference/29/modwsgi) ]支持 WSGI。

web2py 提供了一个文件`wsgihandler.py`来连接 WSGI。

一些网络托管服务不支持 mod_wsgi。在这种情况下，我们必须使用 Apache 作为代理，并将所有传入请求转发到 web2py 内置 Web 服务器（例如在 localhost:8000 上运行）。

在这两种情况下，使用 mod_wsgi 和/或 mod_proxy，Apache 可以配置为提供静态文件并直接处理 SSL 加密，从而减轻 web2py 的负担。

Nginx 使用 uWSGI 而不是 WSGI，这是一个类似但不同的协议，需要自己的 python 适配器。

Lighttpd Web 服务器目前不支持 WSGI 接口，但它支持 FastCGI [ [fastcgi](http://web2py.com/books/default/reference/29/fastcgi) ] 接口，这是对 CGI 的改进。FastCGI 的主要目标是减少与 Web 服务器和 CGI 程序接口相关的开销，允许服务器一次处理更多的 HTTP 请求。

据 Lighttpd 网站称，“Lighttpd 为 YouTube 和 Wikipedia 等几个流行的 Web 2.0 网站提供支持。它的高速 IO 基础设施使它们能够在相同的硬件上比使用替代网络服务器更好地扩展数倍”。事实上，使用 FastCGI 的 Lighttpd 比使用 mod_wsgi 的 Apache 快。

web2py 提供了一个文件`fcgihandler.py`来连接 FastCGI。

web2py 还包括一个`gaehandler.py`与 Google App Engine (GAE) 的接口。在 GAE 上，Web 应用程序“在云中”运行。这意味着该框架完全抽象了任何硬件细节。Web 应用程序会根据需要自动复制多次，以服务所有并发请求。在这种情况下，复制意味着单个服务器上的多个线程；这也意味着不同服务器上的多个进程。GAE 通过阻止对文件系统的写访问来实现这种级别的可扩展性，并且所有持久性信息都必须存储在 Google BigTable 数据存储或内存缓存中。

在非 GAE 平台上，可扩展性是一个需要解决的问题，并且可能需要对 web2py 应用程序进行一些调整。实现可扩展性的最常见方法是在负载均衡器后面使用多个 Web 服务器（简单的循环，或更复杂的方法，从服务器接收心跳反馈）。

即使有多个 Web 服务器，也必须有一个，并且只有一个数据库服务器。默认情况下，web2py 使用文件系统来存储会话、错误票证、上传的文件和缓存。这意味着在默认配置中，对应的文件夹必须是共享文件夹。



![图片](http://web2py.com/books/default/image/29/en9100.png)



在本章的其余部分，我们会考虑各种可能对这种幼稚方法进行改进的方法，包括：

- 将会话存储在数据库中、缓存中或根本不存储会话。
- 将票据存储在本地文件系统上，并分批移入数据库。
- 使用 memcache 代替 cache.ram 和 cache.disk。
- 将上传的文件存储在数据库中，而不是共享文件系统中。

虽然我们建议遵循前三个方案，但第四个方案可能主要在小文件的情况下提供优势，但对大文件可能适得其反。



#### `anyserver.py`





Web2py 带有一个名为的文件`anyserver.py`，它实现了以下流行服务器的 WSGI 接口：bjoern, cgi, cherrypy, diesel, eventlet, fapws, flup, gevent, gunicorn, mongrel2, paste, rocket, tornado, twisted, wsgiref

您可以使用这些服务器中的任何一个，例如 Tornado，只需执行以下操作：

```
python anyserver.py -s tornado -i 127.0.0.1 -p 8000 -l -P
```

这`-l`是用于记录和`-P`探查器的。有关所有命令行选项的信息，请使用“-h”：

```
python anyserver.py -h
```



### Linux 和 Unix



#### 一步生产部署

以下是从头开始安装 apache+python+mod_wsgi+web2py+postgresql 的一些步骤。

在 Ubuntu 上：

```
wget https://raw.githubusercontent.com/web2py/web2py/master/scripts/setup-web2py-ubuntu.sh
chmod +x setup-web2py-ubuntu.sh
sudo ./setup-web2py-ubuntu.sh
```

在 Fedora 上：

```
wget https://raw.githubusercontent.com/web2py/web2py/master/scripts/setup-web2py-fedora.sh
chmod +x setup-web2py-fedora.sh
sudo ./setup-web2py-fedora.sh
```

这两个脚本都应该开箱即用，但是每个 Linux 安装都有些不同，因此请确保在运行这些脚本之前检查它们的源代码。在 Ubuntu 的情况下，他们所做的大部分工作将在下面解释。它们没有实现下面讨论的可扩展性优化。



#### 阿帕奇设置

在本节中，我们使用 Ubuntu Server Edition 作为参考平台。配置命令在其他基于 Debian 的 Linux 发行版上非常相似，但对于基于 Fedora 的系统（使用`yum`代替`apt-get`）可能有所不同。您可以使用 2.2.x 或 2.4.x

首先，通过键入以下 shell 命令确保安装了所有必要的 Python 和 Apache 包：

```
sudo apt-get update
sudo apt-get -y upgrade
sudo apt-get -y install openssh-server
sudo apt-get -y install python
sudo apt-get -y install python-dev
sudo apt-get -y install apache2
sudo apt-get -y install libapache2-mod-wsgi
sudo apt-get -y install libapache2-mod-proxy-html
```

然后，在 Apache 中启用 SSL 模块、代理模块和 WSGI 模块：

```
sudo ln -s /etc/apache2/mods-available/proxy_http.load            /etc/apache2/mods-enabled/proxy_http.load
sudo a2enmod ssl
sudo a2enmod proxy
sudo a2enmod proxy_http
sudo a2enmod wsgi
  
```

创建 SSL 文件夹，并将 SSL 证书放入其中：

```
sudo  mkdir  / etc / apache2 / ssl
```

您应该从受信任的证书颁发机构（例如 verisign.com）获取您的 SSL 证书，但是，出于测试目的，您可以按照参考文献中的说明生成自己的自签名证书。[ [openssl](http://web2py.com/books/default/reference/29/openssl) ]

然后重启网络服务器：

```
sudo /etc/init.d/apache2 restart
```

Apache的配置文件是：

```
/etc/apache2/sites-available/default
```

Apache 日志位于：

```
/ var / log / apache2 /
```



#### mod_wsgi

在上面安装了 Web 服务器的机器上下载并解压缩 web2py 源代码。

`/home/www-data/`例如，在 下安装 web2py ，并将所有权授予用户 www-data 和组 www-data。可以使用以下 shell 命令执行这些步骤：

```
cd /home/www-data/
sudo wget http://web2py.com/examples/static/web2py_src.zip
sudo unzip web2py_src.zip
sudo chown -R www-data:www-data /home/www-data/web2py 
```

要使用 mod_wsgi 设置 web2py，请创建一个新的 Apache 配置文件：

```
/etc/apache2/sites-available/web2py
```

并包含以下代码：

```
<VirtualHost *:80>
  ServerName web2py.example.com
  WSGIDaemonProcess web2py user=www-data group=www-data display-name=%{GROUP}
  WSGIProcessGroup web2py
  WSGIScriptAlias / /home/www-data/web2py/wsgihandler.py

#This is Apache 2.2.x permission syntax. See Apache docs for 2.4 syntax
# http://httpd.apache.org/docs/2.4/upgrading.html#run-time

  <Directory /home/www-data/web2py>
    AllowOverride None
    Order Allow,Deny
    Deny from all
    <Files wsgihandler.py>
      Allow from all
    </Files>
  </Directory>

  AliasMatch ^/([^/]+)/static/(?:_[\d]+.[\d]+.[\d]+/)?(.*)            /home/www-data/web2py/applications/$1/static/$2
  <Directory /home/www-data/web2py/applications/*/static/>
    Order Allow,Deny
    Allow from all
  </Directory>

  <Location /admin>
  Deny from all
  </Location>

  <LocationMatch ^/([^/]+)/appadmin>
  Deny from all
  </LocationMatch>

  CustomLog /private/var/log/apache2/access.log common
  ErrorLog /private/var/log/apache2/error.log
</VirtualHost>
```

当你重新启动 Apache 时，它应该将所有请求传递给 web2py，而不通过 Rocket wsgiserver。

##### 移动处理程序脚本

最后，您需要重新定位处理程序脚本`web2py/handlers/wsgihandler.py`。正如handlers 目录中所述，您需要的脚本应该被移动或复制到父目录（即与脚本相同的目录`web2py.py`）。符号链接可能会导致 apache 权限问题。

##### 一些wsgi背景

以下是一些解释：

```
WSGIDaemonProcess web2py user=www-data group=www-data display-name=%{GROUP}
```

在“web2py.example.com”的上下文中定义一个守护进程组。通过在虚拟主机内部定义这个，只有这个虚拟主机可以使用 WSGIProcessGroup 访问它，包括任何具有相同服务器名称但在不同端口上的虚拟主机。“用户”和“组”选项应设置为对设置 web2py 的目录具有写入权限的用户。如果您使 web2py 安装目录可由 Apache 运行的默认用户写入，则不需要设置“用户”和“组”。“display-name”选项使进程名称出现在`ps`输出为“（wsgi-web2py）”而不是Apache Web服务器可执行文件的名称。由于没有指定“进程”或“线程”选项，因此守护进程组将有一个进程，其中有 15 个线程在该进程中运行。对于大多数站点来说，这通常绰绰有余，应该保持原样。如果覆盖它，请不要使用“processes=1”，因为这样做会禁用任何检查“wsgi.multiprocess”标志的浏览器内 WSGI 调试工具。这是因为“进程”选项的任何使用都会导致该标志设置为 true，甚至是单个进程，并且此类工具希望将其设置为 false。注意：如果您的应用程序代码或第三方扩展模块不是线程安全的，请改用选项“processes=5 threads=1”。这将在守护进程组中创建五个进程，其中每个进程都是单线程的。如果您的应用程序由于无法正确进行垃圾收集而泄漏 Python 对象，您可能会考虑使用“maximum-requests=1000”。

```
WSGIProcessGroup  web2py
```

将所有 WSGI 应用程序的运行委托给使用 WSGIDaemonProcess 指令配置的守护进程组。

```
WSGIScriptAlias  //  home / www - data / web2py / wsgihandler . _ py
```

挂载 web2py 应用程序。在这种情况下，它安装在网站的根目录。

```
<Directory /home/www-data/web2py>
  ...
</Directory>
```

授予 Apache 访问 WSGI 脚本文件的权限。

```
< Directory  / home / www - data / web2py / applications /*/ static /> 
  Order  Allow , Deny 
  Allow  from  all 
</ Directory >
```

指示 Apache 在搜索静态文件时绕过 web2py。

```
<Location /admin>
  Deny from all
</Location>
```

和

```
<LocationMatch ^/([^/]+)/appadmin>
  Deny from all
</LocationMatch>
```

**阻止对admin**和**appadmin**的公共访问

通常我们只允许访问 WSGI 脚本文件所在的整个目录，但是 web2py 将 WSGI 脚本文件放在包含其他源代码的目录中，包括管理界面密码。打开整个目录会导致安全问题，因为从技术上讲，Apache 将被允许将所有文件提供给通过映射 URL 遍历到该目录的任何用户。为避免安全问题，明确拒绝对目录内容的访问，WSGI 脚本文件除外，并禁止用户对 .htaccess 文件进行任何覆盖以提高安全性。

您可以在以下位置找到完整的、注释的 Apache wsgi 配置文件：

```
scripts/web2py-wsgi.conf
```

本部分是在 mod_wsgi 的开发者 Graham Dumpleton 的帮助下创建的。



#### 设置密码

在生产中，可能需要以编程方式设置管理员密码。这可以通过 Bash shell 完成

```
sudo -u www-data python -c "from gluon.main import save_password; save_password(raw_input('admin password: '), 443)" 
```



#### mod_wsgi 和 SSL

要强制某些应用程序（例如**admin**和**appadmin**）通过 HTTPS，请存储 SSL 证书和密钥文件：

```
/etc/apache2/ssl/server.crt
/etc/apache2/ssl/server.key
```

并编辑 Apache 配置文件`web2py.conf`并附加：

```
<VirtualHost *:443>
  ServerName web2py.example.com
  SSLEngine on
  SSLCertificateFile /etc/apache2/ssl/server.crt
  SSLCertificateKeyFile /etc/apache2/ssl/server.key

  WSGIProcessGroup web2py

  WSGIScriptAlias / /home/www-data/web2py/wsgihandler.py

  <Directory /home/www-data/web2py>
    AllowOverride None
    Order Allow,Deny
    Deny from all
    <Files wsgihandler.py>
      Allow from all
    </Files>
  </Directory>

  AliasMatch ^/([^/]+)/static/(?:_[\d]+.[\d]+.[\d]+/)?(.*)         /home/www-data/web2py/applications/$1/static/$2

  <Directory /home/www-data/web2py/applications/*/static/>
    Order Allow,Deny
    Allow from all
  </Directory>

  CustomLog /private/var/log/apache2/access.log common
  ErrorLog /private/var/log/apache2/error.log

</VirtualHost>
```

重新启动 Apache，您应该能够访问：

```
https://www.example.com/admin
https://www.example.com/examples/appadmin
http://www.example.com/examples
```

但不是：

```
http://www.example.com/admin
http://www.example.com/examples/appadmin
```



#### mod_proxy

一些 Unix/Linux 发行版可以运行 Apache，但不支持 mod_wsgi。在这种情况下，最简单的解决方案是将 Apache 作为代理运行，让 Apache 只处理静态文件。

这是一个最小的 Apache 配置：

```
NameVirtualHost *:80
#### deal with requests on port 80
<VirtualHost *:80>
   Alias / /home/www-data/web2py/applications
   ### serve static files directly
   <LocationMatch "^/welcome/static/.*">
    Order Allow, Deny
    Allow from all
   </LocationMatch>
   ### proxy all the other requests
   <Location "/welcome">
     Order deny,allow
     Allow from all
     ProxyRequests off
     ProxyPass http://localhost:8000/welcome
     ProxyPassReverse http://localhost:8000/
     ProxyHTMLURLMap http://127.0.0.1:8000/welcome/ /welcome
   </Location>
   LogFormat "%h %l %u %t "%r" %>s %b" common
   CustomLog /var/log/apache2/access.log common
</VirtualHost>
```

上面的脚本只公开了“欢迎”应用程序。要公开其他应用程序，您需要使用与“欢迎”应用程序相同的语法添加相应的 <Location>...</Location>。

该脚本假设有一个 web2py 服务器在端口 8000 上运行。在重新启动 Apache 之前，请确保是这种情况：

```
nohup python web2py.py -a '<recycle>' -i 127.0.0.1 -p 8000 &
```

您可以使用选项指定密码`-a`或使用“<recycle>”参数代替密码。在后一种情况下，先前存储的密码会被重用，并且密码不会存储在 shell 历史记录中。

您还可以使用参数“<ask>”来提示输入密码。

这些`nohup`命令可确保在您关闭 shell 时服务器不会死机。`nohup`将所有输出记录到`nohup.out`.

要通过 HTTPS 强制 admin 和 appadmin，请改用以下 Apache 配置文件：

```
NameVirtualHost *:80
NameVirtualHost *:443
#### deal with requests on port 80
<VirtualHost *:80>
   Alias / /home/www-data/web2py/applications
   ### admin requires SSL
   <LocationMatch "^/admin">
     SSLRequireSSL
   </LocationMatch>
   ### appadmin requires SSL
   <LocationMatch "^/welcome/appadmin/.*">
     SSLRequireSSL
   </LocationMatch>
   ### serve static files directly
   <LocationMatch "^/welcome/static/.*">
     Order Allow,Deny
     Allow from all
   </LocationMatch>
   ### proxy all the other requests
   <Location "/welcome">
     Order deny,allow
     Allow from all
     ProxyPass http://localhost:8000/welcome
     ProxyPassReverse http://localhost:8000/
   </Location>
   LogFormat "%h %l %u %t "%r" %>s %b" common
   CustomLog /var/log/apache2/access.log common
</VirtualHost>
<VirtualHost *:443>
   SSLEngine On
   SSLCertificateFile /etc/apache2/ssl/server.crt
   SSLCertificateKeyFile /etc/apache2/ssl/server.key
   <Location "/">
     Order deny,allow
     Allow from all
     ProxyPass http://localhost:8000/
     ProxyPassReverse http://localhost:8000/
   </Location>
   LogFormat "%h %l %u %t "%r" %>s %b" common
   CustomLog /var/log/apache2/access.log common
</VirtualHost>
```

> 当 web2py 在带有 mod_proxy 的共享主机上运行时，必须禁用管理界面，否则它将暴露给其他用户。



#### 作为 Linux 守护进程启动

除非您使用 mod_wsgi，否则您应该设置 web2py 服务器，以便它可以像任何其他 Linux 守护程序一样启动/停止/重新启动，因此它可以在计算机启动阶段自动启动。

设置过程特定于各种 Linux/Unix 发行版。

在 web2py 文件夹中，有两个可用于此目的的脚本：

```
scripts/web2py.ubuntu.sh
scripts/web2py.fedora.sh
```

在 Ubuntu 或其他基于 Debian 的 Linux 发行版上，编辑“web2py.ubuntu.sh”并将“/usr/lib/web2py”路径替换为您的 web2py 安装路径，然后键入以下 shell 命令将文件移动到正确的文件夹，将其注册为启动服务，然后启动它：

```
sudo cp scripts/web2py.ubuntu.sh /etc/init.d/web2py
sudo update-rc.d web2py defaults
sudo /etc/init.d/web2py start
```

在 Fedora 或任何其他基于 Fedora 的发行版上，编辑“web2py.fedora.sh”并将“/usr/lib/web2py”路径替换为您的 web2py 安装路径，然后键入以下 shell 命令将文件移动到正确的文件夹，将其注册为启动服务并启动它：

```
sudo cp scripts/web2py.fedora.sh /etc/rc.d/init.d/web2pyd
sudo chkconfig --add web2pyd
sudo service web2py start
```



#### Nginx

Nginx 是一个免费的开源 Web 服务器，因其惊人的性能而迅速普及。

与传统服务器不同，Nginx 不使用线程。相反，它使用异步/事件驱动架构来处理并发。即使在重负载下，这种架构也会产生较小且可预测的内存使用量。

Nginx 不仅仅是一个 HTTP 服务器和反向代理，它还是一个 IMAP/POP3 代理服务器。

Nginx 易于配置，其配置文件比相应的 Apache 更简单、更紧凑。

Nginx 不支持 WSGI，但为 uWSGI [ [uwsgi](http://web2py.com/books/default/reference/29/uwsgi) ]协议提供原生支持。



在 Ubuntu 上，您可以使用以下命令安装 Nginx：

```
apt - get  - y  install  nginx - full
```

然后，您将需要创建一个配置文件，如下所示：

```
# file /etc/nginx/sites-available/web2py
server {
        listen          80;
        server_name     $hostname;
        #to enable correct use of response.static_version
        #location ~* /(\w+)/static(?:/_[\d]+.[\d]+.[\d]+)?/(.*)$ {
        #    alias /home/www-data/web2py/applications/$1/static/$2;
        #    expires max;
        #}
        location ~* /(\w+)/static/ {
            root /home/www-data/web2py/applications/;
            #remove next comment on production
            #expires max;
        }
        location / {
            #uwsgi_pass      127.0.0.1:9001;
            uwsgi_pass      unix:///tmp/web2py.socket;
            include         uwsgi_params;
            uwsgi_param     UWSGI_SCHEME $scheme;
            uwsgi_param     SERVER_SOFTWARE    nginx/$nginx_version;
        }
}
server {
        listen 443 default_server ssl;
        server_name     $hostname;
        ssl_certificate         /etc/nginx/ssl/web2py.crt;
        ssl_certificate_key     /etc/nginx/ssl/web2py.key;
        ssl_prefer_server_ciphers on;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;
        ssl_ciphers ECDHE-RSA-AES256-SHA:DHE-RSA-AES256-SHA:DHE-DSS-AES256-SHA:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA;
        ssl_protocols SSLv3 TLSv1;
        keepalive_timeout    70;
        location / {
            #uwsgi_pass      127.0.0.1:9001;
            uwsgi_pass      unix:///tmp/web2py.socket;
            include         uwsgi_params;
            uwsgi_param     UWSGI_SCHEME $scheme;
            uwsgi_param     SERVER_SOFTWARE    nginx/$nginx_version;
        }

}
```

您将需要对文件进行符号链接并删除默认值

```
ln -s /etc/nginx/sites-available/web2py /etc/nginx/sites-enabled/web2py
rm /etc/nginx/sites-enabled/default
 
```

您可能还需要为证书创建 ssl 文件夹并将证书放入其中：

```
mkdir /etc/nginx/ssl
cp web2py.key /etc/nginx/ssl
cp web2py.crt /etc/nginx/ssl
```

然后你需要安装和设置 uWSGI

```
sudo  mkdir  / etc / uwsgi 
sudo  mkdir  / var / log / uwsgi
```

并创建一个配置文件“/etc/uwsgi/web2py.xml”：

```
<uwsgi>
    <socket>/tmp/web2py.socket</socket>
    <pythonpath>/home/www-data/web2py/</pythonpath>
    <mount>/=wsgihandler:application</mount>
    <master/>
    <processes>4</processes>
    <harakiri>60</harakiri>
    <reload-mercy>8</reload-mercy>
    <cpu-affinity>1</cpu-affinity>
    <stats>/tmp/stats.socket</stats>
    <max-requests>2000</max-requests>
    <limit-as>512</limit-as>
    <reload-on-as>256</reload-on-as>
    <reload-on-rss>192</reload-on-rss>
    <uid>www-data</uid>
    <gid>www-data</gid>
    <no-orphans/>
</uwsgi>
```

该文件假定 web2py 安装在“/home/www-data/web2py”下，就像 Apache 的情况一样。

您还需要编辑第二个配置文件“/etc/init/uwsgi-emperor.conf”：

```
# Emperor uWSGI script
description "uWSGI Emperor"
start on runlevel [2345]
stop on runlevel [06]
respawn
exec uwsgi --master --die-on-term --emperor /etc/uwsgi --logto /var/log/uwsgi/uwsgi.log
```

最后重启一切：

```
start uwsgi-emperor
/etc/init.d/nginx restart
```

您可以使用重新加载 uwsgi

```
restart uwsgi-emperor
```

你可以用

```
stop uwsgi-emperor
```

您只能重新加载 web2py（无需重新启动 uwsgi）

```
touch /etc/uwsgi/web2py.xml
```

所有这些步骤都由提供的脚本自动执行：

```
scripts/setup-web2py-nginx-uwsgi-on-centos.sh
scripts/setup-web2py-nginx-uwsgi-ubuntu.sh
```



#### Lighttpd





您可以使用以下 shell 命令在 Ubuntu 或其他基于 Debian 的 Linux 发行版上安装 Lighttpd：

```
apt-get -y install lighttpd
```

安装后，编辑`/etc/rc.local`并创建一个 fcgi web2py 后台进程

```
cd /var/www/web2py && sudo -u www-data nohup python fcgihandler.py &    
```

然后，您需要编辑 Lighttpd 配置文件

```
/etc/lighttpd/lighttpd.conf
```

以便它可以找到上述进程创建的套接字。在配置文件中，编写如下内容：

```
server.modules              = (
        "mod_access",
        "mod_alias",
        "mod_compress",
        "mod_rewrite",
        "mod_fastcgi",
        "mod_redirect",
        "mod_accesslog",
        "mod_status",
)

server.port = 80
server.bind = "0.0.0.0"
server.event-handler = "freebsd-kqueue"
server.error-handler-404 = "/test.fcgi"
server.document-root = "/home/www-data/web2py/"
server.errorlog      = "/tmp/error.log"

fastcgi.server = (
  "/handler_web2py.fcgi" => (
      "handler_web2py" => ( #name for logs
         "check-local" => "disable",
         "socket" => "/tmp/fcgi.sock"
      )
   ),
)

$HTTP["host"] = "(^|.)example.com$" {
 server.document-root="/var/www/web2py"
    url.rewrite-once = (
      "^(/.+?/static/.+)$" => "/applications$1",
      "(^|/.*)$" => "/handler_web2py.fcgi$1",
    )
}
```

现在检查语法错误：

```
lighttpd -t -f /etc/lighttpd/lighttpd.conf
```

和（重新）启动网络服务器：

```
/etc/init.d/lighttpd restart
```

请注意，FastCGI 将 web2py 服务器绑定到 Unix 套接字，而不是 IP 套接字：

```
/tmp/fcgi.sock
```

这是 Lighttpd 将 HTTP 请求转发到并从中接收响应的地方。Unix 套接字比 Internet 套接字更轻，这也是 Lighttpd+FastCGI+web2py 速度快的原因之一。与 Apache 一样，可以将 Lighttpd 设置为直接处理静态文件，并强制某些应用程序通过 HTTPS。有关详细信息，请参阅 Lighttpd 文档。

本节中的示例取自 John Heenan 在 web2pyslices 中的帖子。

> 当 web2py 在使用 FastCGI 的共享主机上运行时，必须禁用管理界面，否则它将暴露给其他用户。



#### 与 mod_python 共享主机

有时，特别是在共享主机上，没有权限直接配置 Apache 配置文件。在撰写本文时，这些主机中的大多数仍然运行 mod_python，即使它不再支持 mod_wsgi。

你仍然可以运行 web2py。在这里，我们展示了如何设置它的示例。

将 web2py 的内容放入“htdocs”文件夹。

在 web2py 文件夹中，创建一个文件“web2py_modpython.py”文件，其内容如下：

```
from mod_python import apache
import modpythonhandler

def handler(req):
    req.subprocess_env['PATH_INFO'] = req.subprocess_env['SCRIPT_URL']
    return modpythonhandler.handler(req)
```

使用以下内容创建/更新文件“.htaccess”：

```
SetHandler python-program
PythonHandler web2py_modpython
#PythonDebug On
```

此示例由 Niktar 提供。



#### 带有 FastCGI 的切诺基



Cherokee 是一个非常快速的 Web 服务器，并且与 web2py 一样，它为其配置提供了一个支持 AJAX 的基于 Web 的界面。它的 Web 界面是用 Python 编写的。此外，大多数更改都不需要重新启动。



以下是使用 Cherokee 设置 web2py 所需的步骤：

下载切诺基[[切诺基](http://web2py.com/books/default/reference/29/cherokee)]

解压、构建和安装：

```
tar -xzf cherokee-0.9.4.tar.gz
cd cherokee-0.9.4
./configure --enable-fcgi && make
make install
```

至少正常启动 web2py 一次，以确保它创建了“应用程序”文件夹。

使用以下代码编写一个名为“startweb2py.sh”的 shell 脚本：

```
#!/bin/bash 
cd  / var / web2py 
python  / var / web2py / fcgihandler . py  &
```

并赋予脚本执行权限并运行它。这将在 FastCGI 处理程序下启动 web2py。

启动 Cherokee 和 cherokee-admin：

```
sudo nohup cherokee &
sudo nohup cherokee-admin &
```

默认情况下，cherokee-admin 仅在端口 9090 上侦听本地接口。如果您对该计算机具有完全的物理访问权限，这不是问题。如果不是这种情况，您可以使用以下选项强制它绑定到 IP 地址和端口：

```
-b,  --bind[=IP]
-p,  --port=NUM
```

或者做一个 SSH 端口转发（更安全，推荐）：

```
ssh -L 9090:localhost:9090 remotehost
```

在浏览器中打开“http://localhost:9090”。如果一切正常，您将获得 cherokee-admin。

在 cherokee-admin 网页界面中，点击“信息来源”。选择“本地翻译”。编写以下代码，然后单击“添加新”。

```
Nick: web2py
Connection: /tmp/fcgi.sock
Interpreter: /var/web2py/startweb2py.sh
```

最后，执行以下剩余步骤：

- 单击“虚拟服务器”，然后单击“默认”。
- 单击“行为”，然后在其下单击“默认”。
- 从列表框中选择“FastCGI”而不是“列出并发送”。
- 在底部，选择“web2py”作为“应用程序服务器”
- 选中所有复选框（您可以保留 Allow-x-sendfile）。如果显示警告，请禁用并启用其中一个复选框。（它会自动重新提交应用服务器参数。有时它不会，这是一个错误）。
- 将您的浏览器指向“http://yoursite”，将出现“欢迎使用 web2py”。



#### PostgreSQL

PostgreSQL 是一个免费的开源数据库，用于要求苛刻的生产环境，例如存储 .org 域名数据库，并且已被证明可以很好地扩展到数百 TB 的数据。它具有非常快速和可靠的事务支持，并提供自动真空功能，使管理员从大多数数据库维护任务中解放出来。

在 Ubuntu 或其他基于 Debian 的 Linux 发行版上，很容易安装 PostgreSQL 及其 Python API：

```
sudo apt-get -y install postgresql
sudo apt-get -y install python-psycopg2
```

在不同的机器上运行 Web 服务器和数据库服务器是明智的。在这种情况下，运行 Web 服务器的机器应该连接到一个安全的内部（物理）网络，或者应该建立 SSL 隧道来安全地连接到数据库服务器。

编辑 PostgreSQL 配置文件

```
sudo nano /etc/postgresql/9.1/main/postgresql.conf
```

并确保它包含这两行

```
...
listen_addresses = 'localhost'
...
track_counts = on
...
autovacuum = on   # Enable autovacuum subprocess?  'on'
...
```

编辑 PostgreSQL 客户端认证文件

```
sudo nano /etc/postgresql/9.1/main/pg_hba.conf
```

并将这些行的方法更改为`trust`

```
...
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
...
```

使用以下命令启动数据库服务器：

```
sudo /etc/init.d/postgresql restart
```

重新启动 PostgreSQL 服务器时，它应该通知它正在运行的端口。除非您有多个数据库服务器，否则它应该是 5432。

PostgreSQL 日志位于：

```
/ var / log / postgresql /
```

一旦数据库服务器启动并运行，创建一个用户和一个数据库，以便 web2py 应用程序可以使用它：

```
sudo -u postgres createuser -PE -s myuser
postgresql> createdb -O myuser -E UTF8 mydb
postgresql> echo 'The following databases have been created:'
postgresql> psql -l
postgresql> psql mydb
```

第一个命令将授予新用户超级用户访问权限，称为`myuser`. 它会提示您输入密码。

任何 web2py 应用程序都可以使用以下命令连接到该数据库：

```
db  =  DAL ( "postgres://myuser:mypassword@localhost:5432/mydb" )
```

提示时输入的密码在哪里`mypassword`，5432 是数据库服务器运行的端口。

通常，您为每个应用程序使用一个数据库，并且同一应用程序的多个实例连接到同一数据库。不同的应用程序也可以共享同一个数据库。

有关数据库备份的详细信息，请阅读 PostgreSQL 文档；特别是命令`pg_dump`和`pg_restore`.



#### 将调度程序作为 Linux 服务启动（新贵）

要将调度程序安装为 Linux 上的永久守护程序（w/ Upstart），请将以下内容放入 /etc/init/web2py-scheduler.conf，假设您的 web2py 实例安装在 <user> 的主目录中，以 <user 身份运行>，使用应用程序 <myapp>，在网络接口 eth0 上。

```
description "web2py task scheduler"
start on (local-filesystems and net-device-up IFACE=eth0)
stop on shutdown
respawn limit 8 60 # Give up if restart occurs 8 times in 60 seconds.
exec sudo -u <user> python /home/<user>/web2py/web2py.py -K <myapp>
respawn
```

然后，您可以使用以下命令启动/停止/重新启动/检查守护程序的状态：

```
sudo start web2py-scheduler
sudo stop web2py-scheduler
sudo restart web2py-scheduler
sudo status web2py-scheduler
```



#### 重复任务的初始排队

任务定义在模型文件中完成。但是重复任务的初始排队最容易通过非公开的控制器功能完成。通过在控制器而不是模型文件中执行此操作，您可以删除对您网站的每个请求都会发生的不必要的数据库访问。

[该函数也可以在模块或私有文件中，但在控制器中，web2py API 和环境很容易访问。]

非公开函数是任何具有参数的控制器函数，因此在控制器中编写类似以下内容（例如 default.py）会给你

```
def reinit_sched(protect=None):
    # put any preparatory code here
    #
    # schedule 2 tasks:
    sched.queue_task(foo)
    sched.queue_task(bar)
    #
    # put any afters code here
    db.commit()
```

然后您可以轻松地调用它`web2py.py -M -S appname/default/reinit_sched`（可以使用类似的功能来停止重复任务，也许是出于维护原因）



#### 在部署时填充数据库

您的应用程序可能需要预先填充的数据库表。一个简单的示例可能是颜色名称表或月份名称（可能是 Python 日期时间例程中未使用的特殊格式）。更复杂的示例可能包括零件的初始清单或 wiki 的初始页面。

简单的例子可以通过`db.mycolors.insert()`; 更复杂的示例可能使用 CSV 文件来填写值。与上面的任务队列部分一样，这应该使用非公开的控制器功能来完成。数据库的表定义是在模型文件中完成的，但是模型文件是在每个请求上读取的，因此一次性操作不应该在模型文件中，因为它们会降低站点的响应能力。

[该函数也可以在模块或私有文件中，但在控制器中，web2py API 和环境很容易访问。]

同样，非公开函数是任何具有参数的控制器函数，因此在控制器中编写类似以下内容（例如 default.py）会给你

```
def populate_colors(protected=None)
    collist = ["lime", "#00FF00", "olive", "#808000",
                "fuchsia", "#FF00FF", "maroon", "#800000"]:
    for i in range(0, len(collist), 2):
        k, v = collist[i:i+2]
        db.mycolors.insert(name=k, code=v)
    db.commit()
```

然后你可以很容易地调用它`web2py.py -M -S appname/default/populate_colors`

对于使用 CSV 文件的复杂示例，您的函数可能如下所示：

```
def populate_colors(exposed=False):
  db.mycolors.import_from_csv_file( 
    open(os.path.join(request.folder,
                      os.path.join('private', db_colors.csv')
                     ),
         'r') 
    )
  db.commit()
  
```

这将被称为`web2py.py -M -S appname/default/populate_colors`

另请参见第 14 章，[使用 dummy 填充数据库](http://web2py.com/books/default/chapter/29/13/data@chapter/14#Populating-database-with-dummy-data)



### 视窗



#### IIS

如果您不需要为服务器上的某些其他应用程序运行 Apache，那么在现代 Windows 服务器上，在 IIS 后面安装 web2py 会更容易（并且性能更高）。以下步骤说明了如何设置 IIS 以服务 web2py： 需要 Windows Server 2008R2 或更高版本。

我们将从您运行 2012R2 的假设开始。用于 2008R2 的术语略有不同，但协调说明应该不是问题。当然，要求是在服务器上安装 Python，并且您可以使用类似的东西运行 web2py

```
python web2py.py -a 'yourpassword'
```

这意味着您的安装没有任何问题，并且您可以在 IIS 后面成功托管 web2py。

为了运行 Python，IIS 需要安装**CGI**功能。为了使用 IIS 提供静态文件，我们还需要您可以从[此处安装的](http://www.iis.net/downloads/microsoft/url-rewrite)**Url Rewrite模块**

为了让 IIS 与 python “对话”，我们需要从[这里](http://pytools.codeplex.com/releases)安装 wfastcgi 模块。这将安装一个小脚本 wfasctgi.py，它是 IIS 将用来与 Python 通信的处理程序。

现在，打开**Internet 信息服务 (IIS) 管理器**并单击代表服务器的节点。

我们需要创建一个**FastCGI**进程，该进程将映射到运行 web2py 的处理程序。

单击**FastCGI 设置**框，然后单击“添加应用程序”：“完整路径”需要指向 python 可执行文件（类似于“C:\Python27\python.exe”），而“参数”需要指向wfastcgi.py 路径（通常是 C:\Python27\Scripts\wfastcgi.py"）。

从 2.10.4 开始，web2py 附带了一个配置文件（web.config，在示例目录中），它覆盖了默认处理程序以便工作。IIS 配置禁止从配置文件更改处理程序，但禁用检查很容易：转到“功能委托”，找到“处理程序映射”并将其设置为读/写。Web2py 还需要能够在他的目录中写入文件，因此请确保**IIS_IUSRS**组对 web2py 所在的文件夹具有读/写权限。

如果要在 IIS 根目录下使用 web2py，请将源代码复制到 IIS 根目录下（通常是 C:\inetpub\wwwroot）。现在，将 web.config 从示例目录中复制出来，并将其与 web2py.py 一起放在根文件夹中。您只需替换**SCRIPT_PROCESSOR**（接近文件末尾）以匹配我们之前创建的 FastCGI 应用程序：它有一个有趣的语法，但它需要匹配 FastCGI 应用程序的**Full Path|Arguments**格式。

如果您在默认路径中安装了所有内容，则它需要类似于**C:\Python27\python.exe|C:\Python27\Scripts\wfastcgi.py**

这足以将 web2py 用作站点的“根”应用程序。如果您需要在子文件夹下运行 web2py（比如说“web2pyapps”，那么您可以通过http://hostname/web2pyapps/welcome / 访问欢迎应用程序，而不是默认的http://hostname/welcome /），需要两个额外的步骤：

- 将代码移动到名为 web2pyapps 的子文件夹
- `routers = dict(BASE=dict(path_prefix = "web2pyapps")) `在其中创建一个 routes.py 文件
- 在 IIS 管理器中，找到 web2pyapps 文件夹，右键单击它并选择“转换为应用程序”



#### Apache 和 mod_wsgi

在 Windows 下安装 Apache 和 mod_wsgi 需要稍微不同的过程。但是，它与 Linux 非常相似，因此请阅读上面的 Linux Apache 说明。

这里我们假设安装了一个 Windows 二进制 Python 2.x，你从源代码运行并且 web2py 位于`c:/web2py`.

现代 apache Windows 二进制文件（例如 2.4.x）实际上并不是从 apache.org 下载的。相反，您可以从合作伙伴站点下载它们，例如[ApacheHaus](http://www.apachehaus.com/cgi-bin/download.plx)。Apache 网站上有此类合作伙伴的完整列表；搜索 Apache 2.4 Windows 二进制文件。

但是，Windows 二进制文件可能不附带 wsgi 模块。在这种情况下，请访问[modwsgi 主页](http://code.google.com/p/modwsgi/wiki/InstallationOnWindows)（当前位于[http://code.google.com/p/modwsgi/](http://code.google.com/p/modwsgi)）并为您的 python 和 Apache 版本下载预编译的二进制文件。安装 Apache 后，将 .so 库放在模块目录中。

您需要修改 httpd.conf 以加载 wsgi 模块；遵循其他模块加载配置行的示例。

```
LoadModule wsgi_module modules/mod_wsgi.so
```

modwsgi wiki 提到了 Windows 细节：推荐阅读。

您需要根据任何新的 Apache 安装设置 httpd.conf。

Windows 下的证书安装与 Linux 下相同。

Windows 二进制文件很可能被配置为“开箱即用”加载和配置 SSL 模块（Apache Haus 二进制文件就是这样）。

web2py 应该在 https 上提供，也可以在 http 上提供。通常这意味着端口 80 和端口 443，尽管您的 Windows 服务器可能正在使用这些端口，因为可能安装了 IIS，在这种情况下选择备用端口。

但是，我们现在假设为 80 和 443。查找“Listen 80”并在其后添加这一行

```
Listen 443
```

在末尾添加以下行，根据您的值更改驱动器号、端口号、ServerName

```
NameVirtualHost *:443
<VirtualHost *:443>
  DocumentRoot "C:/web2py/applications"
  ServerName server1

  <Directory "C:/web2py">
    Order allow,deny
    Deny from all
  </Directory>

  <Location "/">
    Order deny,allow
    Allow from all
  </Location>

  <LocationMatch "^(/[\w_]*/static/.*)">
    Order Allow,Deny
    Allow from all
  </LocationMatch>

  WSGIScriptAlias / "C:/web2py/wsgihandler.py"
#and don't forget to move the handler script out of the handlers directory

  SSLEngine On
#these cert settings are correct for self-signed certificates
  SSLCertificateFile conf/server.crt
  SSLCertificateKeyFile conf/server.key

  LogFormat "%h %l %u %t "%r" %>s %b" common
  CustomLog logs/access.log common
</VirtualHost>
```

使用以下命令保存并检查配置：[开始 > 程序 > Apache HTTP Server 2.2 > 配置 Apache 服务器 > 测试配置]

如果没有问题，您将看到一个命令屏幕打开和关闭。现在您可以启动 Apache：

[开始 > 程序 > Apache HTTP Server 2.2 > 控制 Apache 服务器 > 开始]

或者更好的是启动任务栏监视器

```
[Start > Program > Apache HTTP Server 2.2 > Control Apache Server]
```

现在您可以右键单击红色羽毛状的任务栏图标以“打开 Apache Monitor”，然后根据需要启动、停止和重新启动 Apache。

本节首先由 Jonathan Lundell 贡献。





#### 使用 nssm 作为 Windows 服务运行

Linux 称之为守护进程，Windows 称之为服务。web2py 内置火箭服务器可以作为 Windows 服务轻松安装/启动/停止。web2py 调度程序也是如此。

开发人员支持外部包装工具“nssm”，而不是在 web2py.py 中维护 Windows 服务代码。

nssm 是一个备受推崇的 Windows 工具，具有良好的功能，例如自动重启服务。这也意味着运行 web2py 服务、调度程序服务和清理过程（如会话删除）的一致方式。不再支持使用以前的 -W 命令行选项。nssm 方法不使用旧方法的 options.py 文件。相反，选项是在命令行上传递的（下面提供了一些示例）

##### nssm 配方：使用 nssm 将调度程序作为 Windows 服务运行

将调度程序作为 Windows 服务运行很有意义。最简单的方法是下载 nssm（来自[htp://www.nssm.cc](htp://www.nssm.cc)）。nssm 是一个开源调度助手。它包装了一个可执行命令以将其转换为服务。启动调度器的命令是*pythonw.exe -K <appname>*我们用nssm把这个包裹起来，变成一个服务。在此之前，您需要为您的服务选择一个名称。为需要调度程序的每个应用程序创建特定服务有很大的优势。因此，您的服务命名约定可能是 web2py_scheduler_app1

解压 nssm zip 文件后，在包含您的体系结构版本（32 位或 64 位）的文件夹中打开 Windows 命令提示符，然后键入

```
nssm install web2py_scheduler_app1
```

这将显示一个对话框，要求您输入应用程序和选项。应用程序是 Python 安装中的 pythonw.exe 可执行文件。选项是命令行的其余部分。您可能需要提供 web2py.py 脚本的完整路径。例如，nssm 对话框中的选项字段可能是：

```
c:\web2py\web2py.py -K app1
```

其中 app1 是您的应用程序的名称。

可以使用多个应用程序调用调度程序。但是，在这种模式下，web2py 将每个应用程序的调度程序分离到一个子进程中。因此，如果其中一个调度程序实例出现问题，服务启动的进程不会死掉；相反，那个子进程会死掉。然后我们就不能在失败的情况下利用 Windows 自动服务重启。每个服务使用一个应用程序可以启用此功能。

##### nssm 配方：将 web2py.py 作为服务运行

上面的例子展示了如何使用 nssm。要在端口 8041 上以 SSL 模式运行 web2py，并包括一些其他选项，您可以给 nssm 一个命令行（在 nssm 对话框的选项字段中），如下所示：

```
c:\web2py.py -p 8041 -i "0.0.0.0" --password="112233" --folder="d:\web2py_internet" --socket-timeout=10 --timeout=120 -c "d:\web2py_internet\applications\example.com.au.crt" -k "d:\web2py_internet\applications\web2py.key
```

（请注意，这不是存储密码的最佳实践，因为显示命令行的任务管理器会显示密码。调查 web2py 命令行选项 -a "<recycle>"）



### 保护会话和**管理员**





公开暴露**管理**应用程序和**appadmin**控制器是非常危险的，除非它们通过 HTTPS 运行。此外，您的密码和凭据绝不应在未加密的情况下传输。对于 web2py 和任何其他 Web 应用程序都是如此。

在您的应用程序中，如果它们需要身份验证，您应该使用以下方法使会话 cookie 安全：

```
session.secure()
```

在服务器上设置安全生产环境的一种简单方法是首先停止 web2py，然后`parameters_*.py`从 web2py 安装文件夹中删除所有文件。然后在没有密码的情况下启动 web2py。这将完全禁用 admin 和 appadmin。

```
nohup python web2py --nogui -p 8001 -i 127.0.0.1 -a '' &    
```

接下来，启动只能从 localhost 访问的第二个 web2py 实例：

```
nohup python web2py --nogui -p 8002 -i 127.0.0.1 -a '<ask>'     
```

并创建一个从本地机器（您希望从中访问管理界面的机器）到服务器（运行 web2py 的机器，example.com）的 SSH 隧道，使用：

```
ssh -L 8002:127.0.0.1:8002 username@example.com
```

现在，您可以通过 Web 浏览器在本地访问管理界面`localhost:8002`。

此配置是安全的，因为当隧道关闭（用户已注销）时无法访问**管理员。**

> 当且仅当其他用户对包含 web2py 的文件夹没有读取权限时，此解决方案在共享主机上是安全的；否则用户可能能够直接从服务器窃取会话 cookie。



### 效率和可扩展性

web2py 旨在易于部署和设置。这并不意味着它会影响效率或可扩展性，但这意味着您可能需要对其进行调整以使其具有可扩展性。

在本节中，我们假设在提供本地负载平衡的 NAT 服务器后面安装了多个 web2py。

在这种情况下，如果满足某些条件，web2py 可以开箱即用。特别是，每个 web2py 应用程序的所有实例都必须访问相同的数据库服务器并且必须看到相同的文件。后一种情况可以通过共享以下文件夹来实现：

```
applications/myapp/sessions
applications/myapp/errors
applications/myapp/uploads
applications/myapp/cache
```

共享文件夹必须支持文件锁定。可能的解决方案是 ZFS（ZFS 由 Sun Microsystems 开发，是首选。）、NFS（使用 NFS，您可能需要运行`nlockmgr`守护程序以允许文件锁定。）或 Samba (SMB)。

可以共享整个 web2py 文件夹或整个应用程序文件夹，但这不是一个好主意，因为这会导致不必要的网络带宽使用增加。

我们相信上面讨论的配置是非常可扩展的，因为它通过将那些需要共享但不需要事务安全的资源移动到共享文件系统来减少数据库负载（一次只有一个客户端应该访问会话文件，缓存总是需要全局锁，上传和错误是一次写入/读取多个文件）。

理想情况下，数据库和共享存储都应该具有 RAID 功能。不要错误地将数据库存储在与共享文件夹相同的存储上，否则您将在那里产生新的瓶颈。

根据具体情况，您可能需要执行其他优化，我们将在下面讨论它们。特别是，我们将讨论如何将这些共享文件夹一一清除，以及如何将关联的数据存储在数据库中。虽然这是可能的，但它不一定是一个好的解决方案。然而，可能有理由这样做。一个这样的原因是有时我们没有设置共享文件夹的自由。



#### 效率技巧

web2py 应用程序代码在每个请求上执行，因此您希望尽量减少此代码量。这是您可以执行的操作：

- 运行一次，`migrate=True`然后将所有表设置为`migrate=False`.
- **字节码使用admin**编译您的应用程序。
- 尽可能多地使用`cache.ram`，但请确保使用有限的密钥集，否则使用的缓存量将任意增长。
- 最小化模型中的代码：不要在那里定义函数，在需要它们的控制器中定义函数，或者 - 甚至更好 - 在模块中定义函数，导入它们并根据需要使用这些函数。
- 不要将许多功能放在同一个控制器中，而应使用多个具有很少功能的控制器。
- 调用`session.forget(response)`所有不改变会话的控制器和/或函数。
- 尽量避免使用 web2py cron，而是使用后台进程。web2py cron 可以启动过多的 Python 实例并导致过多的内存使用。



#### 数据库中的会话

可以指示 web2py 将会话存储在数据库中而不是会话文件夹中。这必须为每个单独的 web2py 应用程序完成，尽管它们可能都使用相同的数据库来存储会话。

给定一个数据库连接

```
db = DAL(...)
```

您可以将会话存储在此数据库 (db) 中，只需在建立连接的同一模型文件中声明以下内容：

```
session.connect(request, response, db)
```

如果它不存在，web2py 在后台创建一个名为`web2py_session_`*appname*的数据库中的表，其中包含以下字段：

```
Field('locked', 'boolean', default=False),
Field('client_ip'),
Field('created_datetime', 'datetime', default=request.now),
Field('modified_datetime', 'datetime'),
Field('unique_key'),
Field('session_data', 'text')
```

“unique_key”是一个 uuid 键，用于在 cookie 中识别会话。“session_data”是 cPickled 会话数据。

为了最大限度地减少数据库访问，您应该避免在不需要时存储会话：

```
session.forget()
```

如果未更改，会话将自动被遗忘。

对于数据库中的会话，“会话”文件夹不需要是共享文件夹，因为它将不再被访问。

> 请注意，如果会话被禁用，则不能传递`session`to `form.accepts`，也不能使用`session.flash`CRUD。



#### HAProxy 高可用性负载均衡器

如果您需要在多台机器上运行多个 web2py 进程，而不是将会话存储在数据库或缓存中，您可以选择使用具有粘性会话的负载均衡器。

Pound [ [pound](http://web2py.com/books/default/reference/29/pound) ] 和 HAProxy [ [haproxy](http://web2py.com/books/default/reference/29/haproxy) ] 是两个 HTTP 负载平衡器和提供粘性会话的反向代理。在这里我们讨论后者，因为它似乎在商业 VPS 托管上更常见。

粘性会话是指一旦发出会话 cookie，负载均衡器将始终将来自与会话关联的客户端的请求路由到同一服务器。这允许您将会话存储在本地文件系统中，而无需共享文件系统。

要使用 HAProxy：

首先，在 Ubuntu 测试机上安装它：

```
sudo apt-get -y install haproxy
```

其次将配置文件“/etc/haproxy.cfg”编辑为如下内容：

```
## this config needs haproxy-1.1.28 or haproxy-1.2.1

global
      log 127.0.0.1   local0
      maxconn 1024
      daemon

defaults
      log     global
      mode    http
      option  httplog
      option  httpchk
      option  httpclose
      retries 3
      option redispatch
      contimeout      5000
      clitimeout      50000
      srvtimeout      50000

listen 0.0.0.0:80
      balance url_param WEB2PYSTICKY
      balance roundrobin
      server  L1_1 10.211.55.1:7003  check
      server  L1_2 10.211.55.2:7004  check
      server  L1_3 10.211.55.3:7004  check
      appsession WEB2PYSTICKY len 52 timeout 1h
```

该`listen`指令告诉 HAProxy，等待来自哪个端口的连接。该`server`指令告诉 HAProxy 在哪里可以找到代理服务器。该目录创建一个粘性会话并使用为此目的`appsession`调用的 cookie 。`WEB2PYSTICKY`

第三，启用此配置文件并启动 HAProxy：

```
/etc/init.d/haproxy restart
```

您可以在 URL 上找到设置 Pound 的类似说明

```
http://web2pyslices.com/main/slices/take_slice/33
```



#### 清理会话

您应该知道，在生产环境中，会话堆积得很快。web2py 提供了一个名为：

```
scripts/sessions2trash.py
```

在后台运行时，会定期删除一段时间内未访问的所有会话。Web2py 提供了一个脚本来清理这些会话（它适用于基于文件的会话和数据库会话）。

以下是一些典型的用例：

- 每 5 分钟删除一次过期会话：

```
nohup python web2py.py -S app -M -R scripts/sessions2trash.py &  
```

或者在 Windows 中，使用上面调度程序部分中描述的 nssm。您可能需要包含 web2py.py 和脚本文件夹的完整路径，并且不需要尾随 &。

- 删除超过 60 分钟的会话，无论是否过期，输出详细信息，然后退出：

```
python web2py.py -S app -M -R scripts/sessions2trash.py -A -o -x 3600 -f -v       
```

- 删除所有会话，无论到期和退出：

```
session2trash.py has it own specific command line options that can be passed while launching web2py shell with the
command line.

NOTE: They must be preceeded by web2py command line option "-A" for them to be passed on to the script.

  -f, --force          Ignore session expiration. Force expiry based on -x option or auth.settings.expiration.
  -o, --once           Delete sessions, then exit. Essential when trigger trash sessions from system CRON JOB
  -s SECONDS, --sleep  Number of seconds to sleep between executions. Default 300.
  -v, --verbose        print verbose output, a second -v increases verbosity
  -x SECONDS, --expiration
                       Expiration value for sessions without expiration (in seconds)        
```

- 最后一个示例，如果您想从系统 CRON JOB 启动 session2trash.py 并删除所有过期会话并退出：

```
python web2py.py -S app -M -R scripts/sessions2trash.py -C -A -o   
```

在前面的示例`app`中是您的应用程序的名称。



#### 上传数据库中的文件

默认情况下，SQLFORMs 处理的所有上传文件都被安全地重命名并存储在“uploads”文件夹下的文件系统中。可以指示 web2py 将上传的文件存储在数据库中。

现在，考虑下表：

```
db.define_table('dog',
    Field('name')
    Field('image', 'upload'))
```

上传类型在哪里`dog.image`。要使上传的图片与狗的名字在同一条记录中，您必须修改表定义，添加一个 blob 字段并将其链接到上传字段：

```
db.define_table('dog',
    Field('name')
    Field('image', 'upload', uploadfield='image_data'),
    Field('image_data', 'blob'))
```

这里的“image_data”只是新 blob 字段的任意名称。

第 3 行指示 web2py 像往常一样安全地重命名上传的图像，将新名称存储在图像字段中，并将数据存储在名为“image_data”的上传字段中，而不是将数据存储在文件系统中。所有这些都由 SQLFORM 自动完成，无需更改其他代码。

通过此调整，不再需要“上传”文件夹。

在 Google App Engine 上，文件默认存储在数据库中，无需定义上传字段，因为默认情况下会创建一个。



#### Collecting tickets

默认情况下，web2py 将票据（错误）存储在本地文件系统上。将票据直接存储在数据库中是没有意义的，因为生产环境中最常见的错误来源是数据库故障。

存储门票永远不会成为瓶颈，因为这通常是罕见的事件。因此，在具有多个并发服务器的生产环境中，将它们存储在共享文件夹中就足够了。尽管如此，由于只有管理员需要检索票证，因此也可以将票证存储在非共享的本地“错误”文件夹中并定期收集和/或清除它们。

一种可能性是定期将所有本地票证移至数据库。

为此，web2py 提供了以下脚本：

```
scripts/tickets2db.py
```

默认情况下，脚本从保存到私有文件夹**ticket_storage.txt**的文件中获取 db uri 。该文件应包含一个直接传递给**DAL**实例的字符串，例如：

```
mysql://username:password@localhost/test
postgres://username:password@localhost/test
...
```

这允许脚本保持原样：如果您有多个应用程序，它将为每个应用程序动态选择正确的连接。如果要硬编码其中的 uri，请在*except*行之后编辑对 db_string 的第二个引用。您可以使用以下命令运行脚本：

```
nohup python web2py.py -S myapp -M -R scripts/tickets2db.py &   
```

其中 myapp 是您的应用程序的名称。

此脚本在后台运行，每 5 分钟将所有工单移动到一个表中，并删除本地工单。稍后您可以使用管理应用程序查看错误，单击顶部的“切换到：db”按钮，其功能与存储在文件系统上的完全相同。

通过此调整，“错误”文件夹不再需要成为共享文件夹，因为错误将存储到数据库中。



#### 内存缓存

我们已经展示了 web2py 提供了两种类型的缓存：`cache.ram`和`cache.disk`. 它们都在具有多个并发服务器的分布式环境中工作，但它们不能按预期工作。特别是，`cache.ram`只会在服务器级别缓存；因此它变得无用。`cache.disk`还将在服务器级别缓存，除非“缓存”文件夹是支持锁定的共享文件夹；因此，它不是加快速度，而是成为主要瓶颈。

解决方案不是使用它们，而是使用 memcache。web2py 带有一个 memcache API。

要使用 memcache，请创建一个新的模型文件，例如`0_memcache.py`，并在此文件中写入（或附加）以下代码：

```
from gluon.contrib.memcache import MemcacheClient
memcache_servers = ['127.0.0.1:11211']
cache.memcache = MemcacheClient(request, memcache_servers)
cache.ram = cache.disk = cache.memcache
```

第一行导入 memcache。第二行必须是内存缓存套接字列表（服务器：端口）。第三行定义`cache.memcache`. 第四行根据 memcache 重新定义了`cache.ram`和`cache.disk`。

您可以选择仅重新定义其中一个来定义一个指向 Memcache 对象的全新缓存对象。

通过此调整，“缓存”文件夹不再需要成为共享文件夹，因为它将不再被访问。

此代码需要在本地网络上运行 memcache 服务器。您应该查阅 memcache 文档以获取有关如何设置这些服务器的信息。



#### 内存缓存中的会话

如果您确实需要会话并且不想使用具有粘性会话的负载均衡器，您可以选择将会话存储在 memcache 中：

```
from gluon.contrib.memdb import MEMDB
session.connect(request, response, db=MEMDB(cache.memcache))
```



#### 使用 Redis 进行缓存

[[重复](http://web2py.com/books/default/reference/29/redis)]

Memcache 的替代方案是使用 Redis。



假设我们在 localhost 的 6379 端口上安装并运行了 Redis，我们可以使用以下代码（在模型中）连接到它：

```
from gluon.contrib.redis_utils import RConn
from gluon.contrib.redis_cache import RedisCache
rconn = RConn('localhost', 6379)
cache.redis = RedisCache(redis_conn=rconn, debug=True)
```

我们现在可以使用和`cache.redis`代替（或一起使用）。`cache.ram``cache.disk`

我们也可以通过调用获取 Redis 统计信息：

```
cache.redis.stats()
```

Redis 缓存子系统允许您防止臭名昭著的“雷群问题”：默认情况下这不是活动的，因为通常您选择 redis 是为了速度，但是您可以以可以忽略不计的成本确保只有一个线程/进程可以同时设置一个值。要激活此行为，只需将`with_lock=True`参数传递给`RedisCache`调用。您还可以使用“按需”启用行为`value = cache.redis('mykey', lambda: time.time(), with_lock=True)`



#### Redis 中的会话

如果您的堆栈中有 Redis，为什么不将它用于会话？

```
from gluon.contrib.redis_utils import RConn
from gluon.contrib.redis_session import RedisSession
rconn = RConn()
sessiondb = RedisSession(redis_conn=rconn, session_expiry=False)
session.connect(request, response, db=sessiondb)
```

该代码已经过大约 1M 次会话的测试。只要 Redis 可以放入内存，处理 1 或 1M 会话所花费的时间是相同的。虽然相对于基于文件的会话或基于数据库的会话，对于约 40K 会话的加速是不明显的，但在这个障碍之上，改进是显着的。当您运行 web2py 实例的“农场”时，也会注意到一个很大的改进，因为共享会话文件夹或将多个进程连接到数据库通常会占用系统。您最终将获得每个会话 1 个密钥，外加 2 个密钥，一个持有整数（需要分配不同的会话密钥），另一个持有生成的所有会话集（因此对于 1000 个会话，1002 个密钥）。

如果`session_expiry`未设置，会话将照常处理，您需要[像往常一样清理会话](http://web2py.com/books/default/chapter/29/13#Cleaning-up-sessions)一次。

但是，when `session_expiry`is set 将在 n 秒后自动删除会话（例如，如果设置为 3600，会话将在最后一次更新后恰好一小时后过期），您应该偶尔运行 session2trash.py 以清理保存该集合的密钥之前发布的所有会话（对于大约 1M 会话，清理需要 3 秒）。会话的 redis 后端是唯一可以防止对同一会话进行并发修改的后端：对于经常以半并发方式写入会话的 ajax 密集型应用程序尤其如此。为了提高速度，默认情况下不强制执行此操作，但是如果您想打开锁定行为，只需将其打开并`with_lock=True`传递给`RedisSession`对象的参数即可。



#### 删除应用程序

在生产环境中，最好不要安装默认应用程序：**admin**、**examples**和**welcome**。尽管这些应用程序很小，但它们不是必需的。

删除这些应用程序就像删除应用程序文件夹下的相应文件夹一样简单。



#### 使用复制数据库

在高性能环境中，您可能有一个主从数据库架构，其中包含许多复制的从属服务器，可能还有几个复制的服务器。DAL 可以处理这种情况，并根据请求参数有条件地连接到不同的服务器。第 6 章中描述了执行此操作的 API。下面是一个示例：

```
from random import sample
db = DAL(sample(['mysql://...1', 'mysql://...2', 'mysql://...3'], 3))
```

在这种情况下，不同的 HTTP 请求将由不同的数据库随机服务，每个 DB 或多或少都会以相同的概率被命中。

我们还可以实现一个简单的 Round-Robin

```
def fail_safe_round_robin(*uris):
     i = cache.ram('round-robin', lambda: 0, None)
     uris = uris[i:]+uris[:i] # rotate the list of uris
     cache.ram('round-robin', lambda: (i+1)%len(uris), 0)
     return uris
db = DAL(fail_safe_round_robin('mysql://...1', 'mysql://...2', 'mysql://...3')) 
```

这是故障安全的，因为如果分配给请求的数据库服务器连接失败，DAL 将尝试按顺序排列的下一个服务器。

根据请求的操作或控制器，也可以连接到不同的数据库。在主从数据库配置中，某些操作仅执行读取，而某些人同时执行读取/写入。前者可以安全地连接到从属数据库服务器，而后者应该连接到主数据库。所以你可以这样做：

```
if request.function in read_only_actions:
   db = DAL(sample(['mysql://...1', 'mysql://...2', 'mysql://...3'], 3))
elif request.action in read_only_actions:
   db = DAL(shuffle(['mysql://...1', 'mysql://...2', 'mysql://...3']))
else:
   db = DAL(sample(['mysql://...3', 'mysql://...4', 'mysql://...5'], 3))
```

其中 1、2、3 是从属设备，3、4、5 是主设备。



#### 压缩静态文件

浏览器可以即时解压缩内容，因此为这些浏览器压缩内容可以节省您和他们的带宽，从而缩短响应时间。如今，大多数 Web 服务器都可以即时压缩您的内容并将其发送到请求 gzip 压缩内容的浏览器。但是，对于静态文件，您会浪费 CPU 周期来一遍又一遍地压缩相同的内容。

您可以使用*scripts/zip_static_files.py*来创建静态文件的 gzip 版本并在不浪费 CPU 的情况下提供这些版本。像`python web2py.py -S myapp -R scripts/zip_static_files.py`在 cron 中一样运行。该脚本负责创建（或更新）gzip 压缩版本并将它们与您的文件一起保存，并在其名称后附加一个 .gz。您只需要让您的网络服务器知道何时发送这些文件[ [apache-content-negotiation](http://web2py.com/books/default/reference/29/apache-content-negotiation) ] [ [nginx-gzipstatic](http://web2py.com/books/default/reference/29/nginx-gzipstatic) ]



### 在 PythonAnywhere 上部署



```
PythonAnywhere
```



PythonAnywhere 是部署 web2py 应用程序的最简单方法。

PythonAnywhere 是一个 Python 开发和托管环境，它显示在您的 Web 浏览器中并在云服务器上运行。它们已经配备了运行 Python 所需的一切，并且专门支持 web2py。根据我们的经验，PythonAnywhere 易于使用、快速且功能强大。他们还提供 MySQL 数据库、python shell 和 Dropbox 集成。如果免费的基本主机对您来说不够用，则可以使用专业主机。

为了使用 PythonAnywhere，您需要创建一个帐户，登录，然后使用提供的 Web Dashboard 添加一个类型为 web2py 的新 Web 应用程序。



![图片](http://web2py.com/books/default/image/29/pythonanywhere1.png)

![图片](http://web2py.com/books/default/image/29/pythonanywhere2.png)



该界面还要求您输入管理密码。



![图片](http://web2py.com/books/default/image/29/pythonanywhere3.png)



web2py 文件夹将在您的用户文件夹中创建。

或者，您也可以像往常一样使用基于 Web 的 BASH shell 来安装 web2py：

```
wget http://www.web2py.com/examples/static/web2py_src.zip
unzip web2py_src.zip
```

始终从 shell 创建一个管理员密码以供以后使用：

```
python -c "from gluon.main import save_password; save_password(raw_input('admin  password: '), 443)"
```

然后使用 Web 界面访问“Web”面板并编辑“/var/www/<username>_pythonanywhere_com_wsgi.py”文件。这是您的程序（在我们的例子中为 web2py）的入口点，您可能猜到，它基于 WSGI 协议。

编辑“/var/www/<username>_pythonanywhere_com_wsgi.py”文件并在其中写入：

```
import sys
path = '/home/<username>/web2py'
if path not in sys.path: sys.path.append(path)
from wsgihandler import application # the web2py handler
    
```

这里“<username>”是您的 PythonAnywhere 用户名。

安装 web2py 后，请注意您不需要启动或配置 Web 服务器。PythonAnywhere 提供了一个，它会在您编辑上述配置文件时重新加载。或按仪表板上的“重新加载网络应用程序”按钮。每个人都可以立即通过 url 访问它：

```
http://yourusername.pythonanywhere.com/
```

他们还提供了网站的安全版本，您必须使用它来使用 web2py 管理界面：

```
https://yourusername.pythonanywhere.com/admin/default/index
```

我们感谢 PythonAnywhere 团队的帮助和支持。



### 在 Heroku 上部署

[[赫鲁库](http://web2py.com/books/default/reference/29/heroku)]



Heroku 是一种现代且敏捷的多平台托管解决方案。它允许您使用 Git 将应用程序推送到云服务器。要使用 Heroku，您必须安装 Git 和 Heroku SDK。您在本地使用 SDK 与 Heroku 交互，您的命令将在服务器上推送和执行。

在 Heroku 上运行的应用程序不能依赖持久文件系统，因为它会定期刷新，因此只有应用程序代码可以存储在文件系统上。所有数据都必须存储在数据库中。Heroku 依赖于 PostgreSQL。然而，PostgreSQL 也使用 Heroku SDK 进行配置，并且数据库的 URI 在运行时动态分配并存储在环境变量中。

这意味着必须修改 web2py 应用程序才能在 Heroku 上工作才能使用数据库。

Web2py 提供了一个“heroku.sh”脚本来帮助你。您需要做的就是更换：

```
db  =  FROM ( ... )
```

在您的代码中：

```
from gluon.contrib.heroku import get_db
db = get_db(name=None, pool_size=10)
```

这`name`是包含 Heroku PostgreSQL URI 的环境变量（类似于`HEROKU_POSTGRESQL_RED_URL`）。它默认为`None`，如果只有一个`HEROKU_POSTGRESQL_*_URL`环境变量，它将使用它。`pool_size`是通常的 DAL 池大小。

在 Heroku 平台上非运行时`get_db`将使用开发数据库“sqlite://heroku.test.sqlite”。

在这两种情况下，会话都将存储在数据库中。

Web2py 提供了一个脚本“scripts/setup-web2py-heroku.sh”来在 heroku 上部署你的 web2py 安装。它执行以下步骤：

它安装 virtualenv 和 psycopg2 驱动程序：

```
sudo  pip  install  virtualenv 
sudo  pip  install  psycopg2
```

它创建并激活一个 virtualenv

```
virtualenv venv --distribute
source venv/bin/activate
```

然后创建一个需求文件：

```
pip freeze > requirements.txt
```

并创建一个“Procfile”，告诉 Heroku 如何启动 web2py：

```
echo "web: python web2py.py -a 'yourpassword' -i 0.0.0.0 -p $PORT" > Procfile
```

您可以更改此行以使用不同的服务器。您必须对其进行编辑以选择您自己的管理员密码。`$PORT`是一个正确转义的变量，因为它的值是在运行时设置的。您还应该考虑使用 gunicorn 启动 web2py，`anyserver.py`因为这是推荐的 Python 网络服务器之一。

最后，该脚本创建了一个 Git 存储库：

```
git init
git add .
git add Procfile
git commit -a -m "first commit"
```

将所有内容推送到 Heroku，并启动它：

```
heroku  create 
git  push  heroku  master 
heroku  addons : add  heroku - postgresql : dev 
heroku  scale  web = 1 
heroku  open
```

`heroku`这是 Heroku SDK 的 shell 命令部分。

我们感谢 Heroku 的 Craig Krestiens 对这个食谱的帮助。



### 在 EC2 上部署

Amazon Elastic Compute Cloud (Amazon EC2) 是一种 Web 服务，可在云中提供可调整大小的计算能力。它是最大和最受欢迎的云之一。许多其他云平台在 EC2 上运行。您可以通过创建和部署磁盘映像在 EC2 上运行任何应用程序。然后，亚马逊提供 API 来复制图像，同时共享部分文件系统。

整个过程的描述超出了本书的范围，但是，假设您有一个现有的 Amazon EC2 帐户，您可以使用 Turnkey Hub 查找并部署现成的 web2py 映像：

```
https://hub.turnkeylinux.org/amazon/launch/web2py/
```

部署映像后，您可以作为普通 VPS 登录，并可以通过 Amazon EC2 Web 界面对其进行管理（备份/恢复/复制）。



### 在 Google App Engine 上部署

可以在 Google App Engine (GAE) [ [gae](http://web2py.com/books/default/reference/29/gae) ]上运行 web2py 代码，包括 DAL 代码。

GAE 支持两个版本的 Python：2.5 和 2.7，但 web2py 需要 2.7。查看下面描述的“app.yaml”文件以获取配置详细信息。

GAE 还支持 Google SQL 数据库（与 MySQL 兼容）和 Google NoSQL（简称“Datastore”）。

web2py 支持两者，并且确实可以同时连接到两者，使用第 6 章中详述的连接字符串。

与普通托管解决方案相比，GAE 平台提供了几个优势：

- 易于部署。谷歌完全抽象了底层架构。
- 可扩展性。Google 将尽可能多地复制您的应用程序，以满足所有并发请求。
- 可以在 SQL 和 NoSQL 数据库（或两者一起）之间进行选择。

但也有一些缺点：

- 没有对文件系统的读取或写入访问权限。
- 并非所有 Python 库都受支持（您可以部署任何纯 Python 库，但不能部署二进制库，但已经安装了 PIL 和 numpy）。

虽然 Google Cloud SQL 是一个常规的 mysql 数据库，但 Google Datastore 有一些特定的缺点：

- 无典型交易；*查询的最终一致性*而不是强一致性。
- 没有复杂的数据存储查询。特别是没有`JOIN`,`LIKE`和`DATE/DATETIME`运算符。

在这里，我们提供了 GAE 的快速概述，我们专注于 web2py 特定问题，我们建议您在线查看官方 GAE 文档以获取详细信息。

> 注意：您必须运行 web2py 源代码分发，而不是二进制分发。



#### 配置

需要注意三个配置文件：

```
web2py/app.yaml
web2py/queue.yaml
web2py/index.yaml
```

`app.yaml`并且`queue.yaml`最容易通过使用模板文件`app.example.yaml`和`queue.example.yaml`作为起点来创建。`index.yaml`由 Google 部署软件自动创建。

`app.yaml`具有以下结构（已使用...缩短）：

```
application: web2py
version: 1
api_version: 1
runtime: python
handlers:
- url: /_ah/stats.*
  ...
- url: /(?P<a>.+?)/static/(?P<b>.+)
  ...
- url: /_ah/admin/.*
  ...
- url: /_ah/queue/default
  ...
- url: .*
  ...
skip_files:
...
```

`app.example.yaml`（复制到 时`app.yaml`）配置为部署 web2py`welcome`应用程序，而不是`admin`或`example`应用程序。您必须替换`web2py`为您在向 Google App Engine 注册时使用的应用程序 ID。

`url: /(.+?)/static/(.+)`指示 GAE 直接为您的应用程序静态文件提供服务，而无需调用 web2py 逻辑，以提高速度。

`url:.*`指示 web2py`gaehandler.py`对所有其他请求使用 。

`skip_files:`会话是不需要在 GAE 上部署的文件的正则表达式列表。特别是以下几行：

```
 (applications/(admin|examples)/.*)|
 ((admin|examples|welcome).(w2p|tar))|
```

告诉 GAE 不要部署默认应用程序，解压后的欢迎脚手架应用程序除外。您可以在此处添加更多要忽略的应用程序。

除了应用程序 id 和版本，您可能不需要编辑`app.yaml`，但您可能希望排除`welcome`应用程序。

该文件`queue.yaml`用于配置 GAE 任务队列。

`index.yaml`当您使用 GAE 应用服务器（Google SDK 附带的 Web 服务器）在本地运行应用程序时，该文件会自动生成。它包含如下内容：

```
indexes:
- kind: person
  properties:
  - name: name
    direction: desc
```

在这个例子中，它告诉 GAE 为表“person”创建一个索引，该索引将用于按字母倒序的“name”排序。如果没有相应的索引，您将无法在应用程序中搜索和排序记录。

在部署之前，始终使用应用服务器在本地运行您的应用并尝试应用的所有功能非常重要。这对于测试目的很重要，而且对于自动生成“index.yaml”文件也很重要。有时您可能想要编辑此文件并执行清理，例如删除重复条目。



#### 运行和部署

##### Linux

这里我们假设您已经安装了 GAE SDK。在撰写本文时，用于 GAE 的 web2py 需要 Python 2.7。您可以使用 appserver 命令从“web2py”文件夹中运行您的应用程序：

```
python dev_appserver.py ../web2py
```

这将启动应用服务器，您可以在 URL 上运行您的应用程序：

```
http://127.0.0.1:8080/
```

为了在 GAE 上上传您的应用程序，请确保您已按照前面的说明编辑了“app.yaml”文件并设置了正确的应用程序 ID，然后运行：

```
python appcfg.py update ../web2py
```

##### Mac、视窗

在 Mac 和 Windows 上，您还可以使用 Google App Engine Launcher。您可以从参考下载软件。[[盖](http://web2py.com/books/default/reference/29/gae)]。

选择【文件】【添加现有应用程序】，将路径设置为顶级web2py文件夹的路径，点击工具栏中的【运行】按钮。在您测试它在本地工作后，您只需单击工具栏上的 [部署] 按钮即可将其部署到 GAE 上（假设您有一个帐户）。



![图片](http://web2py.com/books/default/image/29/en9300.png)



在 GAE 上，web2py 票证/错误也会登录到 GAE 管理控制台，可以在其中在线访问和搜索日志。



![图片](http://web2py.com/books/default/image/29/en9400.png)





#### 配置处理程序

该文件`gaehandler.py`负责在 GAE 上提供文件，它有几个选项。以下是它们的默认值：

```
LOG_STATS = False
APPSTATS = True
DEBUG = False
```

`LOG_STATS`将在 GAE 日志中记录服务页面的时间。

`APPSTATS`将启用提供分析统计信息的 GAE appstats。它们将在以下 URL 提供：

```
http://localhost:8080/_ah/stats
```

`DEBUG`设置调试模式。除非在您的代码中通过`gluon.settings.web2py_runtime`.



#### 避免文件系统

在 GAE 上，您无权访问文件系统。您无法打开任何文件进行写入。

为此，在 GAE 上，web2py 会自动将所有上传的文件存储在数据存储中，无论“上传”字段是否具有`uploadfield`属性。

您还应该将会话和票证存储在数据库中，并且必须明确：

```
if request.env.web2py_runtime_gae
    db = DAL('gae')
    session.connect(request, response, db)
else:
    db = DAL('sqlite://storage.sqlite')
```

上面的代码检查您是否在 GAE 上运行，连接到 BigTable，并指示 web2py 在其中存储会话和票证。否则它会连接到 sqlite 数据库。此代码已在文件“db.py”中的脚手架应用程序中。



#### 内存缓存

如果您愿意，也可以将会话存储在 memcache 中：

```
from gluon.contrib.gae_memcache import MemcacheClient
from gluon.contrib.memdb import MEMDB
cache.memcache = MemcacheClient(request)
cache.ram = cache.disk = cache.memcache
session.connect(request, response, db=MEMDB(cache.memcache.client))
```

请注意，不应使用 GAE 上的 cache.ram 和 cache.disk，因此我们让它们指向 cache.memcache。



#### 数据存储问题

虽然 Google Cloud SQL 用作常规 SQL 数据库，并且在撰写本文时确实基于 mysql，但 Google Datastore 存在显着差异。

##### 缺少 JOIN

Datastore 缺少 JOIN 操作和典型的关系功能需要从 web2py 查询中删除 JOIN 并对数据库进行反规范化。

Google App Engine 支持一些特殊的字段类型，例如`ListProperty`和`StringListProperty`。您可以使用以下旧语法将这些类型与 web2py 一起使用：

```
from gluon.dal import gae
db.define_table('product',
    Field('name'),
    Field('tags', type=gae.StringListProperty())
```

或等效的新语法：

```
db.define_table('product',
    Field('name'),
    Field('tags', 'list:string')
```

在这两种情况下，“tags”字段都是一个，`StringListProperty`因此它的值必须是字符串列表，与 GAE 文档兼容。第二种表示法是首选，因为 web2py 将在表单上下文中以更智能的方式处理该字段，并且它也可以与关系数据库一起使用。

类似地，web2py 支持`list:integer`和`list:reference`which 映射成`ListProperty(int)`.

`list`类型在第 6 章中有更详细的讨论。



#### 数据库迁移

以下是使用 Google AppEngine 进行迁移的良好做法。AppEngine 支持多个代码版本。对用户可见站点使用一个代码版本（例如，版本 1），对管理员代码使用另一个代码版本（例如，版本 2）。在`app.yaml`版本 2 中，如下声明处理程序（假设使用 Python 2.7）：

```
- url: .*
  script: gaehandler.wsgiapp    # WSGI (Python 2.7 only)
  secure: optional
  login: admin
```

该`login: admin`子句确保只有管理员可以使用版本 2。在数据库连接字符串中，指定`migrate_enabled=False`. 要执行迁移，最好禁用与迁移并发的数据库访问。进行如下操作：

- 添加一个名为的文件`DISABLED`到您的版本 1 应用程序的顶层目录（ 、 等目录的父目录`/controllers`）`/views`，并将新版本上传到 GAE。这将禁用版本 1，并显示一条消息*“站点暂时停机以进行维护”*。
- 使用 db 连接字符串上传到版本 2 代码`migrate_enabled=True`，并从管理员帐户访问它，从而触发迁移。
- 使用 ,上传到版本 2 代码`migrate_enabled=False`以禁用进一步的迁移。
- 从版本 1 中删除命名的文件`DISABLED`，并将代码上传到版本 1。这使该站点再次对所有人可见。



#### GAE 和 https

如果您的应用程序的 ID 为“myapp”，则您的 GAE 域是

```
http://myapp.appspot.com/
```

也可以通过HTTPS访问

```
https://myapp.appspot.com/
```

在这种情况下，它将使用 Google 提供的“appspot.com”证书。

您可以注册 DNS 条目并为您的应用程序使用您拥有的任何其他域名，但您将无法在其上使用 HTTPS。在撰写本文时，这是 GAE 限制。